// Author: Igor compiler
// Compiler version: igorc 2.1.3
// DO NOT EDIT THIS FILE - it is machine generated

import * as Igor from './igor';

export enum OrderDirection {
    Asc = 1,
    Desc = 2,
}

export namespace OrderDirection {
    export function toJson(value: OrderDirection): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): OrderDirection {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: OrderDirection): Igor.Json.JsonValue {
        switch (value) {
            case OrderDirection.Asc: return 'asc';
            case OrderDirection.Desc: return 'desc';
            default: throw new Error(`Invalid OrderDirection value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): OrderDirection {
        switch (json) {
            case 'asc': return OrderDirection.Asc;
            case 'desc': return OrderDirection.Desc;
            default: throw new Error(`Invalid OrderDirection value: ${json}`);
        }
    }

    export function getDescription(value: OrderDirection): string {
        switch (value) {
            case OrderDirection.Asc: return '';
            case OrderDirection.Desc: return '';
            default: return '';
        }
    }
}

export enum GameEngine {
    /** Generic */
    Generic = 1,
    /** Unreal Engine 4 */
    Ue4 = 2,
    /** Unity3D */
    Unity = 3,
    /** Hydra Engine */
    Hydra = 4,
    /** CryEngine */
    Cry = 5,
}

export namespace GameEngine {
    export function toJson(value: GameEngine): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameEngine {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameEngine): Igor.Json.JsonValue {
        switch (value) {
            case GameEngine.Generic: return 'generic';
            case GameEngine.Ue4: return 'ue4';
            case GameEngine.Unity: return 'unity';
            case GameEngine.Hydra: return 'hydra';
            case GameEngine.Cry: return 'cry';
            default: throw new Error(`Invalid GameEngine value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameEngine {
        switch (json) {
            case 'generic': return GameEngine.Generic;
            case 'ue4': return GameEngine.Ue4;
            case 'unity': return GameEngine.Unity;
            case 'hydra': return GameEngine.Hydra;
            case 'cry': return GameEngine.Cry;
            default: throw new Error(`Invalid GameEngine value: ${json}`);
        }
    }

    export function getDescription(value: GameEngine): string {
        switch (value) {
            case GameEngine.Generic: return 'Generic';
            case GameEngine.Ue4: return 'Unreal Engine 4';
            case GameEngine.Unity: return 'Unity3D';
            case GameEngine.Hydra: return 'Hydra Engine';
            case GameEngine.Cry: return 'CryEngine';
            default: return '';
        }
    }
}

export enum Platform {
    /** Windows */
    Windows = 1,
    /** Linux */
    Linux = 2,
    /** MacOS */
    Macos = 3,
    /** iOS */
    Ios = 4,
    /** Android */
    Android = 5,
}

export namespace Platform {
    export function toJson(value: Platform): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): Platform {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: Platform): Igor.Json.JsonValue {
        switch (value) {
            case Platform.Windows: return 'windows';
            case Platform.Linux: return 'linux';
            case Platform.Macos: return 'macos';
            case Platform.Ios: return 'ios';
            case Platform.Android: return 'android';
            default: throw new Error(`Invalid Platform value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): Platform {
        switch (json) {
            case 'windows': return Platform.Windows;
            case 'linux': return Platform.Linux;
            case 'macos': return Platform.Macos;
            case 'ios': return Platform.Ios;
            case 'android': return Platform.Android;
            default: throw new Error(`Invalid Platform value: ${json}`);
        }
    }

    export function getDescription(value: Platform): string {
        switch (value) {
            case Platform.Windows: return 'Windows';
            case Platform.Linux: return 'Linux';
            case Platform.Macos: return 'MacOS';
            case Platform.Ios: return 'iOS';
            case Platform.Android: return 'Android';
            default: return '';
        }
    }
}

export enum AccessRole {
    /** Consumer */
    Consumer = 1,
    /** Uploader */
    Uploader = 2,
    /** Maintainer */
    Maintainer = 3,
    /** Administrator */
    Admin = 4,
}

export namespace AccessRole {
    export function toJson(value: AccessRole): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): AccessRole {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: AccessRole): Igor.Json.JsonValue {
        switch (value) {
            case AccessRole.Consumer: return 'consumer';
            case AccessRole.Uploader: return 'uploader';
            case AccessRole.Maintainer: return 'maintainer';
            case AccessRole.Admin: return 'admin';
            default: throw new Error(`Invalid AccessRole value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): AccessRole {
        switch (json) {
            case 'consumer': return AccessRole.Consumer;
            case 'uploader': return AccessRole.Uploader;
            case 'maintainer': return AccessRole.Maintainer;
            case 'admin': return AccessRole.Admin;
            default: throw new Error(`Invalid AccessRole value: ${json}`);
        }
    }

    export function getDescription(value: AccessRole): string {
        switch (value) {
            case AccessRole.Consumer: return 'Consumer';
            case AccessRole.Uploader: return 'Uploader';
            case AccessRole.Maintainer: return 'Maintainer';
            case AccessRole.Admin: return 'Administrator';
            default: return '';
        }
    }
}

export interface IResult {
    result: boolean;
}

export class GenericResponse implements IResult {
    result!: boolean;

    static fromJson(json: Igor.Json.JsonValue): GenericResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GenericResponse();
        obj.result = jsonObject['result'] as boolean;
        return obj;
    }

    static toJson(value: GenericResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GenericResponse.toJson(this);
    }
}

export class Empty {
    static fromJson(json: Igor.Json.JsonValue): Empty {
        const obj = new Empty();
        return obj;
    }

    static toJson(value: Empty): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return Empty.toJson(this);
    }
}

export class Collection<T> {
    items!: Array<T>;

    static fromJson<T>(json: Igor.Json.JsonValue, t: Igor.Json.IJsonSerializer<T>): Collection<T> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Collection<T>();
        obj.items = Igor.Json.List(t).fromJson(jsonObject['items']);
        return obj;
    }

    static toJson<T>(value: Collection<T>, t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['items'] = Igor.Json.List(t).toJson(value.items);
        return result;
    }

    toJson(t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        return Collection.toJson<T>(this, t);
    }

    static instanceJsonSerializer<T>(t: Igor.Json.IJsonSerializer<T>): Igor.Json.IJsonSerializer<Collection<T>> {
        return {
            toJson(value: Collection<T>): Igor.Json.JsonValue {
                return value.toJson(t);
            },

            fromJson(json: Igor.Json.JsonValue): Collection<T> {
                return Collection.fromJson<T>(json, t);
            }
        };
    }
}

export class CollectionSlice<T> {
    total!: number;
    items!: Array<T>;

    static fromJson<T>(json: Igor.Json.JsonValue, t: Igor.Json.IJsonSerializer<T>): CollectionSlice<T> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CollectionSlice<T>();
        obj.total = jsonObject['total'] as number;
        obj.items = Igor.Json.List(t).fromJson(jsonObject['items']);
        return obj;
    }

    static toJson<T>(value: CollectionSlice<T>, t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['total'] = value.total;
        result['items'] = Igor.Json.List(t).toJson(value.items);
        return result;
    }

    toJson(t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        return CollectionSlice.toJson<T>(this, t);
    }

    static instanceJsonSerializer<T>(t: Igor.Json.IJsonSerializer<T>): Igor.Json.IJsonSerializer<CollectionSlice<T>> {
        return {
            toJson(value: CollectionSlice<T>): Igor.Json.JsonValue {
                return value.toJson(t);
            },

            fromJson(json: Igor.Json.JsonValue): CollectionSlice<T> {
                return CollectionSlice.fromJson<T>(json, t);
            }
        };
    }
}

export class BadRequestError<T> {
    error!: T;

    static fromJson<T>(json: Igor.Json.JsonValue, t: Igor.Json.IJsonSerializer<T>): BadRequestError<T> {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BadRequestError<T>();
        obj.error = t.fromJson(jsonObject['error']);
        return obj;
    }

    static toJson<T>(value: BadRequestError<T>, t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['error'] = t.toJson(value.error);
        return result;
    }

    toJson(t: Igor.Json.IJsonSerializer<T>): Igor.Json.JsonValue {
        return BadRequestError.toJson<T>(this, t);
    }

    static instanceJsonSerializer<T>(t: Igor.Json.IJsonSerializer<T>): Igor.Json.IJsonSerializer<BadRequestError<T>> {
        return {
            toJson(value: BadRequestError<T>): Igor.Json.JsonValue {
                return value.toJson(t);
            },

            fromJson(json: Igor.Json.JsonValue): BadRequestError<T> {
                return BadRequestError.fromJson<T>(json, t);
            }
        };
    }
}

export class ForbiddenError {
    static fromJson(json: Igor.Json.JsonValue): ForbiddenError {
        const obj = new ForbiddenError();
        return obj;
    }

    static toJson(value: ForbiddenError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ForbiddenError.toJson(this);
    }
}

export class NotFoundError {
    static fromJson(json: Igor.Json.JsonValue): NotFoundError {
        const obj = new NotFoundError();
        return obj;
    }

    static toJson(value: NotFoundError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return NotFoundError.toJson(this);
    }
}

export class InternalServerError {
    error!: string;

    static fromJson(json: Igor.Json.JsonValue): InternalServerError {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new InternalServerError();
        obj.error = jsonObject['error'] as string;
        return obj;
    }

    static toJson(value: InternalServerError): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['error'] = value.error;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return InternalServerError.toJson(this);
    }
}

export enum Currency {
    Eur = 1,
    Usd = 2,
    Rub = 3,
}

export namespace Currency {
    export function toJson(value: Currency): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): Currency {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: Currency): Igor.Json.JsonValue {
        switch (value) {
            case Currency.Eur: return 'eur';
            case Currency.Usd: return 'usd';
            case Currency.Rub: return 'rub';
            default: throw new Error(`Invalid Currency value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): Currency {
        switch (json) {
            case 'eur': return Currency.Eur;
            case 'usd': return Currency.Usd;
            case 'rub': return Currency.Rub;
            default: throw new Error(`Invalid Currency value: ${json}`);
        }
    }

    export function getDescription(value: Currency): string {
        switch (value) {
            case Currency.Eur: return '';
            case Currency.Usd: return '';
            case Currency.Rub: return '';
            default: return '';
        }
    }
}

export class Price {
    amount!: number;
    currency!: Currency;

    static fromJson(json: Igor.Json.JsonValue): Price {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Price();
        obj.amount = jsonObject['amount'] as number;
        obj.currency = Currency.fromJson(jsonObject['currency']);
        return obj;
    }

    static toJson(value: Price): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['amount'] = value.amount;
        result['currency'] = Currency.toJson(value.currency);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return Price.toJson(this);
    }
}

export enum GameOwnership {
    None = 1,
    Purchase = 2,
    Grant = 3,
    Employee = 4,
}

export namespace GameOwnership {
    export function toJson(value: GameOwnership): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameOwnership {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameOwnership): Igor.Json.JsonValue {
        switch (value) {
            case GameOwnership.None: return 'none';
            case GameOwnership.Purchase: return 'purchase';
            case GameOwnership.Grant: return 'grant';
            case GameOwnership.Employee: return 'employee';
            default: throw new Error(`Invalid GameOwnership value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameOwnership {
        switch (json) {
            case 'none': return GameOwnership.None;
            case 'purchase': return GameOwnership.Purchase;
            case 'grant': return GameOwnership.Grant;
            case 'employee': return GameOwnership.Employee;
            default: throw new Error(`Invalid GameOwnership value: ${json}`);
        }
    }

    export function getDescription(value: GameOwnership): string {
        switch (value) {
            case GameOwnership.None: return '';
            case GameOwnership.Purchase: return '';
            case GameOwnership.Grant: return '';
            case GameOwnership.Employee: return '';
            default: return '';
        }
    }
}

export class IniFileEntry {
    section!: string;
    param!: string;
    value!: string;

    static fromJson(json: Igor.Json.JsonValue): IniFileEntry {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new IniFileEntry();
        obj.section = jsonObject['section'] as string;
        obj.param = jsonObject['param'] as string;
        obj.value = jsonObject['value'] as string;
        return obj;
    }

    static toJson(value: IniFileEntry): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['section'] = value.section;
        result['param'] = value.param;
        result['value'] = value.value;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return IniFileEntry.toJson(this);
    }
}

export enum RegistryValueType {
    /** String */
    String = 1,
    /** Binary */
    Binary = 2,
    /** DWORD (32-bit) */
    Dword = 3,
    /** QWORD (64-bit) */
    Qword = 4,
    /** Multi-String */
    MultiString = 5,
    /** Expandable String */
    ExpandableString = 6,
}

export namespace RegistryValueType {
    export function toJson(value: RegistryValueType): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): RegistryValueType {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: RegistryValueType): Igor.Json.JsonValue {
        switch (value) {
            case RegistryValueType.String: return 'string';
            case RegistryValueType.Binary: return 'binary';
            case RegistryValueType.Dword: return 'dword';
            case RegistryValueType.Qword: return 'qword';
            case RegistryValueType.MultiString: return 'multi_string';
            case RegistryValueType.ExpandableString: return 'expandable_string';
            default: throw new Error(`Invalid RegistryValueType value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): RegistryValueType {
        switch (json) {
            case 'string': return RegistryValueType.String;
            case 'binary': return RegistryValueType.Binary;
            case 'dword': return RegistryValueType.Dword;
            case 'qword': return RegistryValueType.Qword;
            case 'multi_string': return RegistryValueType.MultiString;
            case 'expandable_string': return RegistryValueType.ExpandableString;
            default: throw new Error(`Invalid RegistryValueType value: ${json}`);
        }
    }

    export function getDescription(value: RegistryValueType): string {
        switch (value) {
            case RegistryValueType.String: return 'String';
            case RegistryValueType.Binary: return 'Binary';
            case RegistryValueType.Dword: return 'DWORD (32-bit)';
            case RegistryValueType.Qword: return 'QWORD (64-bit)';
            case RegistryValueType.MultiString: return 'Multi-String';
            case RegistryValueType.ExpandableString: return 'Expandable String';
            default: return '';
        }
    }
}

export class RegistryConfigEntry {
    path!: string;
    key!: string;
    valueType: RegistryValueType = RegistryValueType.String;
    value!: string;

    static fromJson(json: Igor.Json.JsonValue): RegistryConfigEntry {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new RegistryConfigEntry();
        obj.path = jsonObject['path'] as string;
        obj.key = jsonObject['key'] as string;
        obj.valueType = ('value_type' in jsonObject && jsonObject['value_type'] != null) ? RegistryValueType.fromJson(jsonObject['value_type']) : RegistryValueType.String;
        obj.value = jsonObject['value'] as string;
        return obj;
    }

    static toJson(value: RegistryConfigEntry): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['path'] = value.path;
        result['key'] = value.key;
        result['value_type'] = RegistryValueType.toJson(value.valueType);
        result['value'] = value.value;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return RegistryConfigEntry.toJson(this);
    }
}

export class RedistributableEntry {
    name!: string;
    url!: string;

    static fromJson(json: Igor.Json.JsonValue): RedistributableEntry {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new RedistributableEntry();
        obj.name = jsonObject['name'] as string;
        obj.url = jsonObject['url'] as string;
        return obj;
    }

    static toJson(value: RedistributableEntry): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['name'] = value.name;
        result['url'] = value.url;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return RedistributableEntry.toJson(this);
    }
}

export class ClientStatusResponse {
    loggedIn!: boolean;
    userId?: number | null = null;
    email?: string | null = null;
    username?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): ClientStatusResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientStatusResponse();
        obj.loggedIn = jsonObject['logged_in'] as boolean;
        obj.userId = ('user_id' in jsonObject && jsonObject['user_id'] != null) ? jsonObject['user_id'] as number : null;
        obj.email = ('email' in jsonObject && jsonObject['email'] != null) ? jsonObject['email'] as string : null;
        obj.username = ('username' in jsonObject && jsonObject['username'] != null) ? jsonObject['username'] as string : null;
        return obj;
    }

    static toJson(value: ClientStatusResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['logged_in'] = value.loggedIn;
        if (value.userId != null) result['user_id'] = value.userId;
        if (value.email != null) result['email'] = value.email;
        if (value.username != null) result['username'] = value.username;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientStatusResponse.toJson(this);
    }
}

export class ClientRegisterRequest {
    email!: string;
    username!: string;
    password!: string;
    captchaKey?: string | null = null;
    captchaAnswer?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): ClientRegisterRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientRegisterRequest();
        obj.email = jsonObject['email'] as string;
        obj.username = jsonObject['username'] as string;
        obj.password = jsonObject['password'] as string;
        obj.captchaKey = ('captcha_key' in jsonObject && jsonObject['captcha_key'] != null) ? jsonObject['captcha_key'] as string : null;
        obj.captchaAnswer = ('captcha_answer' in jsonObject && jsonObject['captcha_answer'] != null) ? jsonObject['captcha_answer'] as string : null;
        return obj;
    }

    static toJson(value: ClientRegisterRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['email'] = value.email;
        result['username'] = value.username;
        result['password'] = value.password;
        if (value.captchaKey != null) result['captcha_key'] = value.captchaKey;
        if (value.captchaAnswer != null) result['captcha_answer'] = value.captchaAnswer;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientRegisterRequest.toJson(this);
    }
}

export enum ClientRegistrationError {
    Failure = 1,
    InvalidEmail = 2,
    InvalidUsername = 3,
    InvalidPassword = 4,
    EmailAlreadyRegistered = 5,
    UsernameAlreadyRegistered = 6,
    AlreadyLoggedIn = 7,
    InvalidCaptchaKey = 8,
    InvalidCaptchaResponse = 9,
    CaptchaExpired = 10,
}

export namespace ClientRegistrationError {
    export function toJson(value: ClientRegistrationError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ClientRegistrationError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ClientRegistrationError): Igor.Json.JsonValue {
        switch (value) {
            case ClientRegistrationError.Failure: return 'failure';
            case ClientRegistrationError.InvalidEmail: return 'invalid_email';
            case ClientRegistrationError.InvalidUsername: return 'invalid_username';
            case ClientRegistrationError.InvalidPassword: return 'invalid_password';
            case ClientRegistrationError.EmailAlreadyRegistered: return 'email_already_registered';
            case ClientRegistrationError.UsernameAlreadyRegistered: return 'username_already_registered';
            case ClientRegistrationError.AlreadyLoggedIn: return 'already_logged_in';
            case ClientRegistrationError.InvalidCaptchaKey: return 'invalid_captcha_key';
            case ClientRegistrationError.InvalidCaptchaResponse: return 'invalid_captcha_response';
            case ClientRegistrationError.CaptchaExpired: return 'captcha_expired';
            default: throw new Error(`Invalid ClientRegistrationError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ClientRegistrationError {
        switch (json) {
            case 'failure': return ClientRegistrationError.Failure;
            case 'invalid_email': return ClientRegistrationError.InvalidEmail;
            case 'invalid_username': return ClientRegistrationError.InvalidUsername;
            case 'invalid_password': return ClientRegistrationError.InvalidPassword;
            case 'email_already_registered': return ClientRegistrationError.EmailAlreadyRegistered;
            case 'username_already_registered': return ClientRegistrationError.UsernameAlreadyRegistered;
            case 'already_logged_in': return ClientRegistrationError.AlreadyLoggedIn;
            case 'invalid_captcha_key': return ClientRegistrationError.InvalidCaptchaKey;
            case 'invalid_captcha_response': return ClientRegistrationError.InvalidCaptchaResponse;
            case 'captcha_expired': return ClientRegistrationError.CaptchaExpired;
            default: throw new Error(`Invalid ClientRegistrationError value: ${json}`);
        }
    }

    export function getDescription(value: ClientRegistrationError): string {
        switch (value) {
            case ClientRegistrationError.Failure: return '';
            case ClientRegistrationError.InvalidEmail: return '';
            case ClientRegistrationError.InvalidUsername: return '';
            case ClientRegistrationError.InvalidPassword: return '';
            case ClientRegistrationError.EmailAlreadyRegistered: return '';
            case ClientRegistrationError.UsernameAlreadyRegistered: return '';
            case ClientRegistrationError.AlreadyLoggedIn: return '';
            case ClientRegistrationError.InvalidCaptchaKey: return '';
            case ClientRegistrationError.InvalidCaptchaResponse: return '';
            case ClientRegistrationError.CaptchaExpired: return '';
            default: return '';
        }
    }
}

export class ClientRegisterResponse implements IResult {
    result!: boolean;
    error?: ClientRegistrationError | null = null;

    static fromJson(json: Igor.Json.JsonValue): ClientRegisterResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientRegisterResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? ClientRegistrationError.fromJson(jsonObject['error']) : null;
        return obj;
    }

    static toJson(value: ClientRegisterResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = ClientRegistrationError.toJson(value.error);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientRegisterResponse.toJson(this);
    }
}

export class ClientRegisterConfirmRequest {
    username!: string;
    securityCode!: string;

    static fromJson(json: Igor.Json.JsonValue): ClientRegisterConfirmRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientRegisterConfirmRequest();
        obj.username = jsonObject['username'] as string;
        obj.securityCode = jsonObject['security_code'] as string;
        return obj;
    }

    static toJson(value: ClientRegisterConfirmRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['username'] = value.username;
        result['security_code'] = value.securityCode;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientRegisterConfirmRequest.toJson(this);
    }
}

export class ClientResendRequest {
    username!: string;

    static fromJson(json: Igor.Json.JsonValue): ClientResendRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientResendRequest();
        obj.username = jsonObject['username'] as string;
        return obj;
    }

    static toJson(value: ClientResendRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['username'] = value.username;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientResendRequest.toJson(this);
    }
}

export class ClientLoginRequest {
    username!: string;
    password!: string;

    static fromJson(json: Igor.Json.JsonValue): ClientLoginRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientLoginRequest();
        obj.username = jsonObject['username'] as string;
        obj.password = jsonObject['password'] as string;
        return obj;
    }

    static toJson(value: ClientLoginRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['username'] = value.username;
        result['password'] = value.password;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientLoginRequest.toJson(this);
    }
}

export enum ClientLoginError {
    Failure = 1,
    AlreadyLoggedIn = 2,
    AccountNotExists = 3,
    AccountNotActivated = 4,
    AccountIsBlocked = 5,
    AccountIsDeleted = 6,
    InvalidPassword = 7,
}

export namespace ClientLoginError {
    export function toJson(value: ClientLoginError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ClientLoginError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ClientLoginError): Igor.Json.JsonValue {
        switch (value) {
            case ClientLoginError.Failure: return 'failure';
            case ClientLoginError.AlreadyLoggedIn: return 'already_logged_in';
            case ClientLoginError.AccountNotExists: return 'account_not_exists';
            case ClientLoginError.AccountNotActivated: return 'account_not_activated';
            case ClientLoginError.AccountIsBlocked: return 'account_is_blocked';
            case ClientLoginError.AccountIsDeleted: return 'account_is_deleted';
            case ClientLoginError.InvalidPassword: return 'invalid_password';
            default: throw new Error(`Invalid ClientLoginError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ClientLoginError {
        switch (json) {
            case 'failure': return ClientLoginError.Failure;
            case 'already_logged_in': return ClientLoginError.AlreadyLoggedIn;
            case 'account_not_exists': return ClientLoginError.AccountNotExists;
            case 'account_not_activated': return ClientLoginError.AccountNotActivated;
            case 'account_is_blocked': return ClientLoginError.AccountIsBlocked;
            case 'account_is_deleted': return ClientLoginError.AccountIsDeleted;
            case 'invalid_password': return ClientLoginError.InvalidPassword;
            default: throw new Error(`Invalid ClientLoginError value: ${json}`);
        }
    }

    export function getDescription(value: ClientLoginError): string {
        switch (value) {
            case ClientLoginError.Failure: return '';
            case ClientLoginError.AlreadyLoggedIn: return '';
            case ClientLoginError.AccountNotExists: return '';
            case ClientLoginError.AccountNotActivated: return '';
            case ClientLoginError.AccountIsBlocked: return '';
            case ClientLoginError.AccountIsDeleted: return '';
            case ClientLoginError.InvalidPassword: return '';
            default: return '';
        }
    }
}

export class ClientLoginResponse implements IResult {
    result!: boolean;
    error?: ClientLoginError | null = null;
    sessionId?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): ClientLoginResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientLoginResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? ClientLoginError.fromJson(jsonObject['error']) : null;
        obj.sessionId = ('session_id' in jsonObject && jsonObject['session_id'] != null) ? jsonObject['session_id'] as string : null;
        return obj;
    }

    static toJson(value: ClientLoginResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = ClientLoginError.toJson(value.error);
        if (value.sessionId != null) result['session_id'] = value.sessionId;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientLoginResponse.toJson(this);
    }
}

export class ClientPasswordResetRequest {
    username!: string;
    newPassword!: string;
    captchaKey?: string | null = null;
    captchaAnswer?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): ClientPasswordResetRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientPasswordResetRequest();
        obj.username = jsonObject['username'] as string;
        obj.newPassword = jsonObject['new_password'] as string;
        obj.captchaKey = ('captcha_key' in jsonObject && jsonObject['captcha_key'] != null) ? jsonObject['captcha_key'] as string : null;
        obj.captchaAnswer = ('captcha_answer' in jsonObject && jsonObject['captcha_answer'] != null) ? jsonObject['captcha_answer'] as string : null;
        return obj;
    }

    static toJson(value: ClientPasswordResetRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['username'] = value.username;
        result['new_password'] = value.newPassword;
        if (value.captchaKey != null) result['captcha_key'] = value.captchaKey;
        if (value.captchaAnswer != null) result['captcha_answer'] = value.captchaAnswer;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientPasswordResetRequest.toJson(this);
    }
}

export enum ClientPasswordResetError {
    Failure = 1,
    InvalidNewPassword = 2,
    InvalidCaptchaKey = 3,
    InvalidCaptchaResponse = 4,
    CaptchaExpired = 5,
}

export namespace ClientPasswordResetError {
    export function toJson(value: ClientPasswordResetError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ClientPasswordResetError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ClientPasswordResetError): Igor.Json.JsonValue {
        switch (value) {
            case ClientPasswordResetError.Failure: return 'failure';
            case ClientPasswordResetError.InvalidNewPassword: return 'invalid_new_password';
            case ClientPasswordResetError.InvalidCaptchaKey: return 'invalid_captcha_key';
            case ClientPasswordResetError.InvalidCaptchaResponse: return 'invalid_captcha_response';
            case ClientPasswordResetError.CaptchaExpired: return 'captcha_expired';
            default: throw new Error(`Invalid ClientPasswordResetError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ClientPasswordResetError {
        switch (json) {
            case 'failure': return ClientPasswordResetError.Failure;
            case 'invalid_new_password': return ClientPasswordResetError.InvalidNewPassword;
            case 'invalid_captcha_key': return ClientPasswordResetError.InvalidCaptchaKey;
            case 'invalid_captcha_response': return ClientPasswordResetError.InvalidCaptchaResponse;
            case 'captcha_expired': return ClientPasswordResetError.CaptchaExpired;
            default: throw new Error(`Invalid ClientPasswordResetError value: ${json}`);
        }
    }

    export function getDescription(value: ClientPasswordResetError): string {
        switch (value) {
            case ClientPasswordResetError.Failure: return '';
            case ClientPasswordResetError.InvalidNewPassword: return '';
            case ClientPasswordResetError.InvalidCaptchaKey: return '';
            case ClientPasswordResetError.InvalidCaptchaResponse: return '';
            case ClientPasswordResetError.CaptchaExpired: return '';
            default: return '';
        }
    }
}

export class ClientPasswordResetResponse implements IResult {
    result!: boolean;
    error?: ClientPasswordResetError | null = null;

    static fromJson(json: Igor.Json.JsonValue): ClientPasswordResetResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientPasswordResetResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? ClientPasswordResetError.fromJson(jsonObject['error']) : null;
        return obj;
    }

    static toJson(value: ClientPasswordResetResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = ClientPasswordResetError.toJson(value.error);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientPasswordResetResponse.toJson(this);
    }
}

export class ClientPasswordResetConfirmRequest {
    username!: string;
    securityCode!: string;

    static fromJson(json: Igor.Json.JsonValue): ClientPasswordResetConfirmRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientPasswordResetConfirmRequest();
        obj.username = jsonObject['username'] as string;
        obj.securityCode = jsonObject['security_code'] as string;
        return obj;
    }

    static toJson(value: ClientPasswordResetConfirmRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['username'] = value.username;
        result['security_code'] = value.securityCode;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientPasswordResetConfirmRequest.toJson(this);
    }
}

export class ClientPasswordChangeRequest {
    currentPassword!: string;
    newPassword!: string;

    static fromJson(json: Igor.Json.JsonValue): ClientPasswordChangeRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientPasswordChangeRequest();
        obj.currentPassword = jsonObject['current_password'] as string;
        obj.newPassword = jsonObject['new_password'] as string;
        return obj;
    }

    static toJson(value: ClientPasswordChangeRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['current_password'] = value.currentPassword;
        result['new_password'] = value.newPassword;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientPasswordChangeRequest.toJson(this);
    }
}

export enum ClientPasswordChangeError {
    Failure = 1,
    InvalidCurrentPassword = 2,
    InvalidNewPassword = 3,
    NotLoggedIn = 4,
}

export namespace ClientPasswordChangeError {
    export function toJson(value: ClientPasswordChangeError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ClientPasswordChangeError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ClientPasswordChangeError): Igor.Json.JsonValue {
        switch (value) {
            case ClientPasswordChangeError.Failure: return 'failure';
            case ClientPasswordChangeError.InvalidCurrentPassword: return 'invalid_current_password';
            case ClientPasswordChangeError.InvalidNewPassword: return 'invalid_new_password';
            case ClientPasswordChangeError.NotLoggedIn: return 'not_logged_in';
            default: throw new Error(`Invalid ClientPasswordChangeError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ClientPasswordChangeError {
        switch (json) {
            case 'failure': return ClientPasswordChangeError.Failure;
            case 'invalid_current_password': return ClientPasswordChangeError.InvalidCurrentPassword;
            case 'invalid_new_password': return ClientPasswordChangeError.InvalidNewPassword;
            case 'not_logged_in': return ClientPasswordChangeError.NotLoggedIn;
            default: throw new Error(`Invalid ClientPasswordChangeError value: ${json}`);
        }
    }

    export function getDescription(value: ClientPasswordChangeError): string {
        switch (value) {
            case ClientPasswordChangeError.Failure: return '';
            case ClientPasswordChangeError.InvalidCurrentPassword: return '';
            case ClientPasswordChangeError.InvalidNewPassword: return '';
            case ClientPasswordChangeError.NotLoggedIn: return '';
            default: return '';
        }
    }
}

export class ClientPasswordChangeResponse implements IResult {
    result!: boolean;
    error?: ClientPasswordChangeError | null = null;

    static fromJson(json: Igor.Json.JsonValue): ClientPasswordChangeResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientPasswordChangeResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? ClientPasswordChangeError.fromJson(jsonObject['error']) : null;
        return obj;
    }

    static toJson(value: ClientPasswordChangeResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = ClientPasswordChangeError.toJson(value.error);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientPasswordChangeResponse.toJson(this);
    }
}

export class PersonnelStatusResponse {
    loggedIn!: boolean;
    userId?: number | null = null;
    email?: string | null = null;
    username?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): PersonnelStatusResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PersonnelStatusResponse();
        obj.loggedIn = jsonObject['logged_in'] as boolean;
        obj.userId = ('user_id' in jsonObject && jsonObject['user_id'] != null) ? jsonObject['user_id'] as number : null;
        obj.email = ('email' in jsonObject && jsonObject['email'] != null) ? jsonObject['email'] as string : null;
        obj.username = ('username' in jsonObject && jsonObject['username'] != null) ? jsonObject['username'] as string : null;
        return obj;
    }

    static toJson(value: PersonnelStatusResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['logged_in'] = value.loggedIn;
        if (value.userId != null) result['user_id'] = value.userId;
        if (value.email != null) result['email'] = value.email;
        if (value.username != null) result['username'] = value.username;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PersonnelStatusResponse.toJson(this);
    }
}

export class PersonnelLoginRequest {
    username!: string;
    password!: string;

    static fromJson(json: Igor.Json.JsonValue): PersonnelLoginRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PersonnelLoginRequest();
        obj.username = jsonObject['username'] as string;
        obj.password = jsonObject['password'] as string;
        return obj;
    }

    static toJson(value: PersonnelLoginRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['username'] = value.username;
        result['password'] = value.password;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PersonnelLoginRequest.toJson(this);
    }
}

export enum PersonnelLoginError {
    Failure = 1,
    AlreadyLoggedIn = 2,
    AccountNotExists = 3,
    AccountIsBlocked = 4,
    AccountIsDeleted = 5,
    InvalidPassword = 6,
}

export namespace PersonnelLoginError {
    export function toJson(value: PersonnelLoginError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): PersonnelLoginError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: PersonnelLoginError): Igor.Json.JsonValue {
        switch (value) {
            case PersonnelLoginError.Failure: return 'failure';
            case PersonnelLoginError.AlreadyLoggedIn: return 'already_logged_in';
            case PersonnelLoginError.AccountNotExists: return 'account_not_exists';
            case PersonnelLoginError.AccountIsBlocked: return 'account_is_blocked';
            case PersonnelLoginError.AccountIsDeleted: return 'account_is_deleted';
            case PersonnelLoginError.InvalidPassword: return 'invalid_password';
            default: throw new Error(`Invalid PersonnelLoginError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): PersonnelLoginError {
        switch (json) {
            case 'failure': return PersonnelLoginError.Failure;
            case 'already_logged_in': return PersonnelLoginError.AlreadyLoggedIn;
            case 'account_not_exists': return PersonnelLoginError.AccountNotExists;
            case 'account_is_blocked': return PersonnelLoginError.AccountIsBlocked;
            case 'account_is_deleted': return PersonnelLoginError.AccountIsDeleted;
            case 'invalid_password': return PersonnelLoginError.InvalidPassword;
            default: throw new Error(`Invalid PersonnelLoginError value: ${json}`);
        }
    }

    export function getDescription(value: PersonnelLoginError): string {
        switch (value) {
            case PersonnelLoginError.Failure: return '';
            case PersonnelLoginError.AlreadyLoggedIn: return '';
            case PersonnelLoginError.AccountNotExists: return '';
            case PersonnelLoginError.AccountIsBlocked: return '';
            case PersonnelLoginError.AccountIsDeleted: return '';
            case PersonnelLoginError.InvalidPassword: return '';
            default: return '';
        }
    }
}

export class PersonnelLoginResponse implements IResult {
    result!: boolean;
    error?: PersonnelLoginError | null = null;
    sessionId?: string | null = null;
    userId?: number | null = null;
    email?: string | null = null;
    username?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): PersonnelLoginResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PersonnelLoginResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? PersonnelLoginError.fromJson(jsonObject['error']) : null;
        obj.sessionId = ('session_id' in jsonObject && jsonObject['session_id'] != null) ? jsonObject['session_id'] as string : null;
        obj.userId = ('user_id' in jsonObject && jsonObject['user_id'] != null) ? jsonObject['user_id'] as number : null;
        obj.email = ('email' in jsonObject && jsonObject['email'] != null) ? jsonObject['email'] as string : null;
        obj.username = ('username' in jsonObject && jsonObject['username'] != null) ? jsonObject['username'] as string : null;
        return obj;
    }

    static toJson(value: PersonnelLoginResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = PersonnelLoginError.toJson(value.error);
        if (value.sessionId != null) result['session_id'] = value.sessionId;
        if (value.userId != null) result['user_id'] = value.userId;
        if (value.email != null) result['email'] = value.email;
        if (value.username != null) result['username'] = value.username;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PersonnelLoginResponse.toJson(this);
    }
}

export enum CaptchaError {
    Failure = 1,
}

export namespace CaptchaError {
    export function toJson(value: CaptchaError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): CaptchaError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: CaptchaError): Igor.Json.JsonValue {
        switch (value) {
            case CaptchaError.Failure: return 'failure';
            default: throw new Error(`Invalid CaptchaError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): CaptchaError {
        switch (json) {
            case 'failure': return CaptchaError.Failure;
            default: throw new Error(`Invalid CaptchaError value: ${json}`);
        }
    }

    export function getDescription(value: CaptchaError): string {
        switch (value) {
            case CaptchaError.Failure: return '';
            default: return '';
        }
    }
}

export class CaptchaResponse implements IResult {
    result!: boolean;
    error?: CaptchaError | null = null;
    captchaKey?: string | null = null;
    filename?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): CaptchaResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new CaptchaResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? CaptchaError.fromJson(jsonObject['error']) : null;
        obj.captchaKey = ('captcha_key' in jsonObject && jsonObject['captcha_key'] != null) ? jsonObject['captcha_key'] as string : null;
        obj.filename = ('filename' in jsonObject && jsonObject['filename'] != null) ? jsonObject['filename'] as string : null;
        return obj;
    }

    static toJson(value: CaptchaResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = CaptchaError.toJson(value.error);
        if (value.captchaKey != null) result['captcha_key'] = value.captchaKey;
        if (value.filename != null) result['filename'] = value.filename;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return CaptchaResponse.toJson(this);
    }
}

export class GameBranchItem {
    name!: string;
    isDefault!: boolean;
    build?: string | null = null;
    buildTime?: Date | null = null;
    buildChangeList?: string | null = null;
    size!: number;
    compressedSize!: number;
    exePath!: string;
    logPath?: string | null = null;
    crashReportPath?: string | null = null;
    configPath?: string | null = null;
    optionalFileMasks: Array<string> = [];
    preservedFileMasks: Array<string> = [];
    redistributables: Array<RedistributableEntry> = [];
    pdbFiles: Array<string> = [];
    rootUrl!: string;
    gameEngine?: GameEngine | null = null;
    iniConfig!: Array<IniFileEntry>;
    registryConfig!: Array<RegistryConfigEntry>;
    isReportable!: boolean;

    static fromJson(json: Igor.Json.JsonValue): GameBranchItem {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameBranchItem();
        obj.name = jsonObject['name'] as string;
        obj.isDefault = jsonObject['is_default'] as boolean;
        obj.build = ('build' in jsonObject && jsonObject['build'] != null) ? jsonObject['build'] as string : null;
        obj.buildTime = ('build_time' in jsonObject && jsonObject['build_time'] != null) ? Igor.Json.DateSerializer.fromJson(jsonObject['build_time']) : null;
        obj.buildChangeList = ('build_change_list' in jsonObject && jsonObject['build_change_list'] != null) ? jsonObject['build_change_list'] as string : null;
        obj.size = jsonObject['size'] as number;
        obj.compressedSize = jsonObject['compressed_size'] as number;
        obj.exePath = jsonObject['exe_path'] as string;
        obj.logPath = ('log_path' in jsonObject && jsonObject['log_path'] != null) ? jsonObject['log_path'] as string : null;
        obj.crashReportPath = ('crash_report_path' in jsonObject && jsonObject['crash_report_path'] != null) ? jsonObject['crash_report_path'] as string : null;
        obj.configPath = ('config_path' in jsonObject && jsonObject['config_path'] != null) ? jsonObject['config_path'] as string : null;
        obj.optionalFileMasks = ('optional_file_masks' in jsonObject && jsonObject['optional_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['optional_file_masks']) : [];
        obj.preservedFileMasks = ('preserved_file_masks' in jsonObject && jsonObject['preserved_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['preserved_file_masks']) : [];
        obj.redistributables = ('redistributables' in jsonObject && jsonObject['redistributables'] != null) ? Igor.Json.List(RedistributableEntry).fromJson(jsonObject['redistributables']) : [];
        obj.pdbFiles = ('pdb_files' in jsonObject && jsonObject['pdb_files'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['pdb_files']) : [];
        obj.rootUrl = jsonObject['root_url'] as string;
        obj.gameEngine = ('game_engine' in jsonObject && jsonObject['game_engine'] != null) ? GameEngine.fromJson(jsonObject['game_engine']) : null;
        obj.iniConfig = Igor.Json.List(IniFileEntry).fromJson(jsonObject['ini_config']);
        obj.registryConfig = Igor.Json.List(RegistryConfigEntry).fromJson(jsonObject['registry_config']);
        obj.isReportable = jsonObject['is_reportable'] as boolean;
        return obj;
    }

    static toJson(value: GameBranchItem): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['name'] = value.name;
        result['is_default'] = value.isDefault;
        if (value.build != null) result['build'] = value.build;
        if (value.buildTime != null) result['build_time'] = Igor.Json.DateSerializer.toJson(value.buildTime);
        if (value.buildChangeList != null) result['build_change_list'] = value.buildChangeList;
        result['size'] = value.size;
        result['compressed_size'] = value.compressedSize;
        result['exe_path'] = value.exePath;
        if (value.logPath != null) result['log_path'] = value.logPath;
        if (value.crashReportPath != null) result['crash_report_path'] = value.crashReportPath;
        if (value.configPath != null) result['config_path'] = value.configPath;
        result['optional_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.optionalFileMasks);
        result['preserved_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.preservedFileMasks);
        result['redistributables'] = Igor.Json.List(RedistributableEntry).toJson(value.redistributables);
        result['pdb_files'] = Igor.Json.List(Igor.Json.String).toJson(value.pdbFiles);
        result['root_url'] = value.rootUrl;
        if (value.gameEngine != null) result['game_engine'] = GameEngine.toJson(value.gameEngine);
        result['ini_config'] = Igor.Json.List(IniFileEntry).toJson(value.iniConfig);
        result['registry_config'] = Igor.Json.List(RegistryConfigEntry).toJson(value.registryConfig);
        result['is_reportable'] = value.isReportable;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameBranchItem.toJson(this);
    }
}

export class GameBranch {
    id!: number;
    rev!: number;
    gameId!: string;
    gameTitle!: string;
    title!: string;
    description!: string;
    password!: string;
    buildId?: number | null = null;
    buildRev?: string | null = null;
    buildCommentary?: string | null = null;
    buildChangeList?: string | null = null;
    buildTotalSize?: number | null = null;
    buildCompressedSize?: number | null = null;
    buildExePath?: string | null = null;
    buildLogPath?: string | null = null;
    buildCrashReportPath?: string | null = null;
    buildCdnRootUrl?: string | null = null;
    buildConfigPath?: string | null = null;
    buildOptionalFileMasks?: Array<string> | null = null;
    buildPreservedFileMasks?: Array<string> | null = null;
    buildRedistributables?: Array<RedistributableEntry> | null = null;
    buildPdbFiles?: Array<string> | null = null;
    buildCreatedAt?: Date | null = null;
    gameEngine?: GameEngine | null = null;
    platform!: Platform;
    iniConfig!: Array<IniFileEntry>;
    registryConfig!: Array<RegistryConfigEntry>;
    isReportable!: boolean;
    isPublic!: boolean;
    isDefault!: boolean;
    isDeleted!: boolean;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): GameBranch {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameBranch();
        obj.id = jsonObject['id'] as number;
        obj.rev = jsonObject['rev'] as number;
        obj.gameId = jsonObject['game_id'] as string;
        obj.gameTitle = jsonObject['game_title'] as string;
        obj.title = jsonObject['title'] as string;
        obj.description = jsonObject['description'] as string;
        obj.password = jsonObject['password'] as string;
        obj.buildId = ('build_id' in jsonObject && jsonObject['build_id'] != null) ? jsonObject['build_id'] as number : null;
        obj.buildRev = ('build_rev' in jsonObject && jsonObject['build_rev'] != null) ? jsonObject['build_rev'] as string : null;
        obj.buildCommentary = ('build_commentary' in jsonObject && jsonObject['build_commentary'] != null) ? jsonObject['build_commentary'] as string : null;
        obj.buildChangeList = ('build_change_list' in jsonObject && jsonObject['build_change_list'] != null) ? jsonObject['build_change_list'] as string : null;
        obj.buildTotalSize = ('build_total_size' in jsonObject && jsonObject['build_total_size'] != null) ? jsonObject['build_total_size'] as number : null;
        obj.buildCompressedSize = ('build_compressed_size' in jsonObject && jsonObject['build_compressed_size'] != null) ? jsonObject['build_compressed_size'] as number : null;
        obj.buildExePath = ('build_exe_path' in jsonObject && jsonObject['build_exe_path'] != null) ? jsonObject['build_exe_path'] as string : null;
        obj.buildLogPath = ('build_log_path' in jsonObject && jsonObject['build_log_path'] != null) ? jsonObject['build_log_path'] as string : null;
        obj.buildCrashReportPath = ('build_crash_report_path' in jsonObject && jsonObject['build_crash_report_path'] != null) ? jsonObject['build_crash_report_path'] as string : null;
        obj.buildCdnRootUrl = ('build_cdn_root_url' in jsonObject && jsonObject['build_cdn_root_url'] != null) ? jsonObject['build_cdn_root_url'] as string : null;
        obj.buildConfigPath = ('build_config_path' in jsonObject && jsonObject['build_config_path'] != null) ? jsonObject['build_config_path'] as string : null;
        obj.buildOptionalFileMasks = ('build_optional_file_masks' in jsonObject && jsonObject['build_optional_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['build_optional_file_masks']) : null;
        obj.buildPreservedFileMasks = ('build_preserved_file_masks' in jsonObject && jsonObject['build_preserved_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['build_preserved_file_masks']) : null;
        obj.buildRedistributables = ('build_redistributables' in jsonObject && jsonObject['build_redistributables'] != null) ? Igor.Json.List(RedistributableEntry).fromJson(jsonObject['build_redistributables']) : null;
        obj.buildPdbFiles = ('build_pdb_files' in jsonObject && jsonObject['build_pdb_files'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['build_pdb_files']) : null;
        obj.buildCreatedAt = ('build_created_at' in jsonObject && jsonObject['build_created_at'] != null) ? Igor.Json.DateSerializer.fromJson(jsonObject['build_created_at']) : null;
        obj.gameEngine = ('game_engine' in jsonObject && jsonObject['game_engine'] != null) ? GameEngine.fromJson(jsonObject['game_engine']) : null;
        obj.platform = Platform.fromJson(jsonObject['platform']);
        obj.iniConfig = Igor.Json.List(IniFileEntry).fromJson(jsonObject['ini_config']);
        obj.registryConfig = Igor.Json.List(RegistryConfigEntry).fromJson(jsonObject['registry_config']);
        obj.isReportable = jsonObject['is_reportable'] as boolean;
        obj.isPublic = jsonObject['is_public'] as boolean;
        obj.isDefault = jsonObject['is_default'] as boolean;
        obj.isDeleted = jsonObject['is_deleted'] as boolean;
        obj.createdAt = Igor.Json.DateSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: GameBranch): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['rev'] = value.rev;
        result['game_id'] = value.gameId;
        result['game_title'] = value.gameTitle;
        result['title'] = value.title;
        result['description'] = value.description;
        result['password'] = value.password;
        if (value.buildId != null) result['build_id'] = value.buildId;
        if (value.buildRev != null) result['build_rev'] = value.buildRev;
        if (value.buildCommentary != null) result['build_commentary'] = value.buildCommentary;
        if (value.buildChangeList != null) result['build_change_list'] = value.buildChangeList;
        if (value.buildTotalSize != null) result['build_total_size'] = value.buildTotalSize;
        if (value.buildCompressedSize != null) result['build_compressed_size'] = value.buildCompressedSize;
        if (value.buildExePath != null) result['build_exe_path'] = value.buildExePath;
        if (value.buildLogPath != null) result['build_log_path'] = value.buildLogPath;
        if (value.buildCrashReportPath != null) result['build_crash_report_path'] = value.buildCrashReportPath;
        if (value.buildCdnRootUrl != null) result['build_cdn_root_url'] = value.buildCdnRootUrl;
        if (value.buildConfigPath != null) result['build_config_path'] = value.buildConfigPath;
        if (value.buildOptionalFileMasks != null) result['build_optional_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.buildOptionalFileMasks);
        if (value.buildPreservedFileMasks != null) result['build_preserved_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.buildPreservedFileMasks);
        if (value.buildRedistributables != null) result['build_redistributables'] = Igor.Json.List(RedistributableEntry).toJson(value.buildRedistributables);
        if (value.buildPdbFiles != null) result['build_pdb_files'] = Igor.Json.List(Igor.Json.String).toJson(value.buildPdbFiles);
        if (value.buildCreatedAt != null) result['build_created_at'] = Igor.Json.DateSerializer.toJson(value.buildCreatedAt);
        if (value.gameEngine != null) result['game_engine'] = GameEngine.toJson(value.gameEngine);
        result['platform'] = Platform.toJson(value.platform);
        result['ini_config'] = Igor.Json.List(IniFileEntry).toJson(value.iniConfig);
        result['registry_config'] = Igor.Json.List(RegistryConfigEntry).toJson(value.registryConfig);
        result['is_reportable'] = value.isReportable;
        result['is_public'] = value.isPublic;
        result['is_default'] = value.isDefault;
        result['is_deleted'] = value.isDeleted;
        result['created_at'] = Igor.Json.DateSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameBranch.toJson(this);
    }
}

export class GameItem {
    guid!: string;
    title!: string;
    description!: string;
    jiraKey?: string | null = null;
    seleneKey?: string | null = null;
    discordUrl?: string | null = null;
    branches: Array<GameBranchItem> = [];
    price!: Price;
    ownership!: GameOwnership;
    ownershipUntil?: Date | null = null;
    categories: Array<number> = [];

    static fromJson(json: Igor.Json.JsonValue): GameItem {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameItem();
        obj.guid = jsonObject['guid'] as string;
        obj.title = jsonObject['title'] as string;
        obj.description = jsonObject['description'] as string;
        obj.jiraKey = ('jira_key' in jsonObject && jsonObject['jira_key'] != null) ? jsonObject['jira_key'] as string : null;
        obj.seleneKey = ('selene_key' in jsonObject && jsonObject['selene_key'] != null) ? jsonObject['selene_key'] as string : null;
        obj.discordUrl = ('discord_url' in jsonObject && jsonObject['discord_url'] != null) ? jsonObject['discord_url'] as string : null;
        obj.branches = ('branches' in jsonObject && jsonObject['branches'] != null) ? Igor.Json.List(GameBranchItem).fromJson(jsonObject['branches']) : [];
        obj.price = Price.fromJson(jsonObject['price']);
        obj.ownership = GameOwnership.fromJson(jsonObject['ownership']);
        obj.ownershipUntil = ('ownership_until' in jsonObject && jsonObject['ownership_until'] != null) ? Igor.Json.DateSerializer.fromJson(jsonObject['ownership_until']) : null;
        obj.categories = ('categories' in jsonObject && jsonObject['categories'] != null) ? Igor.Json.List(Igor.Json.Number).fromJson(jsonObject['categories']) : [];
        return obj;
    }

    static toJson(value: GameItem): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['guid'] = value.guid;
        result['title'] = value.title;
        result['description'] = value.description;
        if (value.jiraKey != null) result['jira_key'] = value.jiraKey;
        if (value.seleneKey != null) result['selene_key'] = value.seleneKey;
        if (value.discordUrl != null) result['discord_url'] = value.discordUrl;
        result['branches'] = Igor.Json.List(GameBranchItem).toJson(value.branches);
        result['price'] = value.price.toJson();
        result['ownership'] = GameOwnership.toJson(value.ownership);
        if (value.ownershipUntil != null) result['ownership_until'] = Igor.Json.DateSerializer.toJson(value.ownershipUntil);
        result['categories'] = Igor.Json.List(Igor.Json.Number).toJson(value.categories);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameItem.toJson(this);
    }
}

export class Game {
    id!: string;
    rev!: number;
    title!: string;
    description!: string;
    jiraKey?: string | null = null;
    seleneKey?: string | null = null;
    ciUrl?: string | null = null;
    discordUrl?: string | null = null;
    price!: number;
    currency!: string;
    buildLifetime!: number;
    categories: Array<number> = [];
    isPublished!: boolean;
    isDisabled!: boolean;
    isDeleted!: boolean;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): Game {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Game();
        obj.id = jsonObject['id'] as string;
        obj.rev = jsonObject['rev'] as number;
        obj.title = jsonObject['title'] as string;
        obj.description = jsonObject['description'] as string;
        obj.jiraKey = ('jira_key' in jsonObject && jsonObject['jira_key'] != null) ? jsonObject['jira_key'] as string : null;
        obj.seleneKey = ('selene_key' in jsonObject && jsonObject['selene_key'] != null) ? jsonObject['selene_key'] as string : null;
        obj.ciUrl = ('ci_url' in jsonObject && jsonObject['ci_url'] != null) ? jsonObject['ci_url'] as string : null;
        obj.discordUrl = ('discord_url' in jsonObject && jsonObject['discord_url'] != null) ? jsonObject['discord_url'] as string : null;
        obj.price = jsonObject['price'] as number;
        obj.currency = jsonObject['currency'] as string;
        obj.buildLifetime = jsonObject['build_lifetime'] as number;
        obj.categories = ('categories' in jsonObject && jsonObject['categories'] != null) ? Igor.Json.List(Igor.Json.Number).fromJson(jsonObject['categories']) : [];
        obj.isPublished = jsonObject['is_published'] as boolean;
        obj.isDisabled = jsonObject['is_disabled'] as boolean;
        obj.isDeleted = jsonObject['is_deleted'] as boolean;
        obj.createdAt = Igor.Json.DateSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: Game): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['rev'] = value.rev;
        result['title'] = value.title;
        result['description'] = value.description;
        if (value.jiraKey != null) result['jira_key'] = value.jiraKey;
        if (value.seleneKey != null) result['selene_key'] = value.seleneKey;
        if (value.ciUrl != null) result['ci_url'] = value.ciUrl;
        if (value.discordUrl != null) result['discord_url'] = value.discordUrl;
        result['price'] = value.price;
        result['currency'] = value.currency;
        result['build_lifetime'] = value.buildLifetime;
        result['categories'] = Igor.Json.List(Igor.Json.Number).toJson(value.categories);
        result['is_published'] = value.isPublished;
        result['is_disabled'] = value.isDisabled;
        result['is_deleted'] = value.isDeleted;
        result['created_at'] = Igor.Json.DateSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return Game.toJson(this);
    }
}

export class GameFile {
    relativePath!: string;
    relativeCompressedPath!: string;
    md5!: string;
    size!: number;
    compressedSize!: number;

    static fromJson(json: Igor.Json.JsonValue): GameFile {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameFile();
        obj.relativePath = jsonObject['relative_path'] as string;
        obj.relativeCompressedPath = jsonObject['relative_compressed_path'] as string;
        obj.md5 = jsonObject['md5'] as string;
        obj.size = jsonObject['size'] as number;
        obj.compressedSize = jsonObject['compressed_size'] as number;
        return obj;
    }

    static toJson(value: GameFile): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['relative_path'] = value.relativePath;
        result['relative_compressed_path'] = value.relativeCompressedPath;
        result['md5'] = value.md5;
        result['size'] = value.size;
        result['compressed_size'] = value.compressedSize;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameFile.toJson(this);
    }
}

export class GameItemList {
    games: Array<GameItem> = [];

    static fromJson(json: Igor.Json.JsonValue): GameItemList {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameItemList();
        obj.games = ('games' in jsonObject && jsonObject['games'] != null) ? Igor.Json.List(GameItem).fromJson(jsonObject['games']) : [];
        return obj;
    }

    static toJson(value: GameItemList): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['games'] = Igor.Json.List(GameItem).toJson(value.games);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameItemList.toJson(this);
    }
}

export class GameManifest {
    buildRev?: string | null = null;
    files: Array<GameFile> = [];

    static fromJson(json: Igor.Json.JsonValue): GameManifest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameManifest();
        obj.buildRev = ('build_rev' in jsonObject && jsonObject['build_rev'] != null) ? jsonObject['build_rev'] as string : null;
        obj.files = ('files' in jsonObject && jsonObject['files'] != null) ? Igor.Json.List(GameFile).fromJson(jsonObject['files']) : [];
        return obj;
    }

    static toJson(value: GameManifest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.buildRev != null) result['build_rev'] = value.buildRev;
        result['files'] = Igor.Json.List(GameFile).toJson(value.files);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameManifest.toJson(this);
    }
}

export class BranchUnlockRequest {
    password!: string;

    static fromJson(json: Igor.Json.JsonValue): BranchUnlockRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BranchUnlockRequest();
        obj.password = jsonObject['password'] as string;
        return obj;
    }

    static toJson(value: BranchUnlockRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['password'] = value.password;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return BranchUnlockRequest.toJson(this);
    }
}

export class ChangeLog {
    buildRev!: string;
    buildCreatedAt!: Date;
    buildChangeList!: string;

    static fromJson(json: Igor.Json.JsonValue): ChangeLog {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ChangeLog();
        obj.buildRev = jsonObject['build_rev'] as string;
        obj.buildCreatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['build_created_at']);
        obj.buildChangeList = jsonObject['build_change_list'] as string;
        return obj;
    }

    static toJson(value: ChangeLog): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['build_rev'] = value.buildRev;
        result['build_created_at'] = Igor.Json.DateSerializer.toJson(value.buildCreatedAt);
        result['build_change_list'] = value.buildChangeList;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ChangeLog.toJson(this);
    }
}

export enum GameOrderBy {
    Id = 1,
    Title = 2,
    Description = 3,
    Price = 4,
    Currency = 5,
    IsPublished = 6,
    IsDisabled = 7,
    IsDeleted = 8,
    CreatedAt = 9,
    UpdatedAt = 10,
}

export namespace GameOrderBy {
    export function toJson(value: GameOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case GameOrderBy.Id: return 'id';
            case GameOrderBy.Title: return 'title';
            case GameOrderBy.Description: return 'description';
            case GameOrderBy.Price: return 'price';
            case GameOrderBy.Currency: return 'currency';
            case GameOrderBy.IsPublished: return 'is_published';
            case GameOrderBy.IsDisabled: return 'is_disabled';
            case GameOrderBy.IsDeleted: return 'is_deleted';
            case GameOrderBy.CreatedAt: return 'created_at';
            case GameOrderBy.UpdatedAt: return 'updated_at';
            default: throw new Error(`Invalid GameOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameOrderBy {
        switch (json) {
            case 'id': return GameOrderBy.Id;
            case 'title': return GameOrderBy.Title;
            case 'description': return GameOrderBy.Description;
            case 'price': return GameOrderBy.Price;
            case 'currency': return GameOrderBy.Currency;
            case 'is_published': return GameOrderBy.IsPublished;
            case 'is_disabled': return GameOrderBy.IsDisabled;
            case 'is_deleted': return GameOrderBy.IsDeleted;
            case 'created_at': return GameOrderBy.CreatedAt;
            case 'updated_at': return GameOrderBy.UpdatedAt;
            default: throw new Error(`Invalid GameOrderBy value: ${json}`);
        }
    }

    export function getDescription(value: GameOrderBy): string {
        switch (value) {
            case GameOrderBy.Id: return '';
            case GameOrderBy.Title: return '';
            case GameOrderBy.Description: return '';
            case GameOrderBy.Price: return '';
            case GameOrderBy.Currency: return '';
            case GameOrderBy.IsPublished: return '';
            case GameOrderBy.IsDisabled: return '';
            case GameOrderBy.IsDeleted: return '';
            case GameOrderBy.CreatedAt: return '';
            case GameOrderBy.UpdatedAt: return '';
            default: return '';
        }
    }
}

export class GameCreateRequest {
    id!: string;
    title!: string;
    price!: number;
    currency!: string;

    static fromJson(json: Igor.Json.JsonValue): GameCreateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameCreateRequest();
        obj.id = jsonObject['id'] as string;
        obj.title = jsonObject['title'] as string;
        obj.price = jsonObject['price'] as number;
        obj.currency = jsonObject['currency'] as string;
        return obj;
    }

    static toJson(value: GameCreateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['title'] = value.title;
        result['price'] = value.price;
        result['currency'] = value.currency;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameCreateRequest.toJson(this);
    }
}

export enum GameCreateError {
    Failure = 1,
    GameIdAlreadyExists = 2,
    GameTitleAlreadyExists = 3,
    InvalidPrice = 4,
    InvalidCurrency = 5,
}

export namespace GameCreateError {
    export function toJson(value: GameCreateError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameCreateError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameCreateError): Igor.Json.JsonValue {
        switch (value) {
            case GameCreateError.Failure: return 'failure';
            case GameCreateError.GameIdAlreadyExists: return 'game_id_already_exists';
            case GameCreateError.GameTitleAlreadyExists: return 'game_title_already_exists';
            case GameCreateError.InvalidPrice: return 'invalid_price';
            case GameCreateError.InvalidCurrency: return 'invalid_currency';
            default: throw new Error(`Invalid GameCreateError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameCreateError {
        switch (json) {
            case 'failure': return GameCreateError.Failure;
            case 'game_id_already_exists': return GameCreateError.GameIdAlreadyExists;
            case 'game_title_already_exists': return GameCreateError.GameTitleAlreadyExists;
            case 'invalid_price': return GameCreateError.InvalidPrice;
            case 'invalid_currency': return GameCreateError.InvalidCurrency;
            default: throw new Error(`Invalid GameCreateError value: ${json}`);
        }
    }

    export function getDescription(value: GameCreateError): string {
        switch (value) {
            case GameCreateError.Failure: return '';
            case GameCreateError.GameIdAlreadyExists: return '';
            case GameCreateError.GameTitleAlreadyExists: return '';
            case GameCreateError.InvalidPrice: return '';
            case GameCreateError.InvalidCurrency: return '';
            default: return '';
        }
    }
}

export class GameCreateResponse implements IResult {
    result!: boolean;
    error?: GameCreateError | null = null;
    game?: Game | null = null;

    static fromJson(json: Igor.Json.JsonValue): GameCreateResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameCreateResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? GameCreateError.fromJson(jsonObject['error']) : null;
        obj.game = ('game' in jsonObject && jsonObject['game'] != null) ? Game.fromJson(jsonObject['game']) : null;
        return obj;
    }

    static toJson(value: GameCreateResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = GameCreateError.toJson(value.error);
        if (value.game != null) result['game'] = value.game.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameCreateResponse.toJson(this);
    }
}

export class GameUpdateRequest {
    title?: string | null = null;
    description?: string | null = null;
    jiraKey?: string | null = null;
    seleneKey?: string | null = null;
    ciUrl?: string | null = null;
    discordUrl?: string | null = null;
    price?: number | null = null;
    currency?: string | null = null;
    buildLifetime?: number | null = null;
    isPublished?: boolean | null = null;
    isDisabled?: boolean | null = null;
    isDeleted?: boolean | null = null;

    static fromJson(json: Igor.Json.JsonValue): GameUpdateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameUpdateRequest();
        obj.title = ('title' in jsonObject && jsonObject['title'] != null) ? jsonObject['title'] as string : null;
        obj.description = ('description' in jsonObject && jsonObject['description'] != null) ? jsonObject['description'] as string : null;
        obj.jiraKey = ('jira_key' in jsonObject && jsonObject['jira_key'] != null) ? jsonObject['jira_key'] as string : null;
        obj.seleneKey = ('selene_key' in jsonObject && jsonObject['selene_key'] != null) ? jsonObject['selene_key'] as string : null;
        obj.ciUrl = ('ci_url' in jsonObject && jsonObject['ci_url'] != null) ? jsonObject['ci_url'] as string : null;
        obj.discordUrl = ('discord_url' in jsonObject && jsonObject['discord_url'] != null) ? jsonObject['discord_url'] as string : null;
        obj.price = ('price' in jsonObject && jsonObject['price'] != null) ? jsonObject['price'] as number : null;
        obj.currency = ('currency' in jsonObject && jsonObject['currency'] != null) ? jsonObject['currency'] as string : null;
        obj.buildLifetime = ('build_lifetime' in jsonObject && jsonObject['build_lifetime'] != null) ? jsonObject['build_lifetime'] as number : null;
        obj.isPublished = ('is_published' in jsonObject && jsonObject['is_published'] != null) ? jsonObject['is_published'] as boolean : null;
        obj.isDisabled = ('is_disabled' in jsonObject && jsonObject['is_disabled'] != null) ? jsonObject['is_disabled'] as boolean : null;
        obj.isDeleted = ('is_deleted' in jsonObject && jsonObject['is_deleted'] != null) ? jsonObject['is_deleted'] as boolean : null;
        return obj;
    }

    static toJson(value: GameUpdateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.title != null) result['title'] = value.title;
        if (value.description != null) result['description'] = value.description;
        if (value.jiraKey != null) result['jira_key'] = value.jiraKey;
        if (value.seleneKey != null) result['selene_key'] = value.seleneKey;
        if (value.ciUrl != null) result['ci_url'] = value.ciUrl;
        if (value.discordUrl != null) result['discord_url'] = value.discordUrl;
        if (value.price != null) result['price'] = value.price;
        if (value.currency != null) result['currency'] = value.currency;
        if (value.buildLifetime != null) result['build_lifetime'] = value.buildLifetime;
        if (value.isPublished != null) result['is_published'] = value.isPublished;
        if (value.isDisabled != null) result['is_disabled'] = value.isDisabled;
        if (value.isDeleted != null) result['is_deleted'] = value.isDeleted;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameUpdateRequest.toJson(this);
    }
}

export enum GameUpdateError {
    Failure = 1,
    RevMismatch = 2,
    NothingToUpdate = 3,
    GameTitleAlreadyExists = 4,
    InvalidGameTitle = 5,
    InvalidJiraKey = 6,
    InvalidSeleneKey = 7,
    InvalidCiUrl = 8,
    InvalidDiscordUrl = 9,
    InvalidPrice = 10,
    InvalidCurrency = 11,
    InvalidBuildLifetime = 12,
}

export namespace GameUpdateError {
    export function toJson(value: GameUpdateError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameUpdateError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameUpdateError): Igor.Json.JsonValue {
        switch (value) {
            case GameUpdateError.Failure: return 'failure';
            case GameUpdateError.RevMismatch: return 'rev_mismatch';
            case GameUpdateError.NothingToUpdate: return 'nothing_to_update';
            case GameUpdateError.GameTitleAlreadyExists: return 'game_title_already_exists';
            case GameUpdateError.InvalidGameTitle: return 'invalid_game_title';
            case GameUpdateError.InvalidJiraKey: return 'invalid_jira_key';
            case GameUpdateError.InvalidSeleneKey: return 'invalid_selene_key';
            case GameUpdateError.InvalidCiUrl: return 'invalid_ci_url';
            case GameUpdateError.InvalidDiscordUrl: return 'invalid_discord_url';
            case GameUpdateError.InvalidPrice: return 'invalid_price';
            case GameUpdateError.InvalidCurrency: return 'invalid_currency';
            case GameUpdateError.InvalidBuildLifetime: return 'invalid_build_lifetime';
            default: throw new Error(`Invalid GameUpdateError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameUpdateError {
        switch (json) {
            case 'failure': return GameUpdateError.Failure;
            case 'rev_mismatch': return GameUpdateError.RevMismatch;
            case 'nothing_to_update': return GameUpdateError.NothingToUpdate;
            case 'game_title_already_exists': return GameUpdateError.GameTitleAlreadyExists;
            case 'invalid_game_title': return GameUpdateError.InvalidGameTitle;
            case 'invalid_jira_key': return GameUpdateError.InvalidJiraKey;
            case 'invalid_selene_key': return GameUpdateError.InvalidSeleneKey;
            case 'invalid_ci_url': return GameUpdateError.InvalidCiUrl;
            case 'invalid_discord_url': return GameUpdateError.InvalidDiscordUrl;
            case 'invalid_price': return GameUpdateError.InvalidPrice;
            case 'invalid_currency': return GameUpdateError.InvalidCurrency;
            case 'invalid_build_lifetime': return GameUpdateError.InvalidBuildLifetime;
            default: throw new Error(`Invalid GameUpdateError value: ${json}`);
        }
    }

    export function getDescription(value: GameUpdateError): string {
        switch (value) {
            case GameUpdateError.Failure: return '';
            case GameUpdateError.RevMismatch: return '';
            case GameUpdateError.NothingToUpdate: return '';
            case GameUpdateError.GameTitleAlreadyExists: return '';
            case GameUpdateError.InvalidGameTitle: return '';
            case GameUpdateError.InvalidJiraKey: return '';
            case GameUpdateError.InvalidSeleneKey: return '';
            case GameUpdateError.InvalidCiUrl: return '';
            case GameUpdateError.InvalidDiscordUrl: return '';
            case GameUpdateError.InvalidPrice: return '';
            case GameUpdateError.InvalidCurrency: return '';
            case GameUpdateError.InvalidBuildLifetime: return '';
            default: return '';
        }
    }
}

export class GameUpdateResponse implements IResult {
    result!: boolean;
    error?: GameUpdateError | null = null;
    game?: Game | null = null;

    static fromJson(json: Igor.Json.JsonValue): GameUpdateResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameUpdateResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? GameUpdateError.fromJson(jsonObject['error']) : null;
        obj.game = ('game' in jsonObject && jsonObject['game'] != null) ? Game.fromJson(jsonObject['game']) : null;
        return obj;
    }

    static toJson(value: GameUpdateResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = GameUpdateError.toJson(value.error);
        if (value.game != null) result['game'] = value.game.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameUpdateResponse.toJson(this);
    }
}

export enum GameBranchOrderBy {
    Id = 1,
    Title = 2,
    BuildId = 3,
    BuildRev = 4,
    BuildTotalSize = 5,
    BuildCompressedSize = 6,
    BuildCreatedAt = 7,
    GameEngine = 8,
    Platform = 9,
    IsPublic = 10,
    IsDefault = 11,
    IsDeleted = 12,
    CreatedAt = 13,
    UpdatedAt = 14,
}

export namespace GameBranchOrderBy {
    export function toJson(value: GameBranchOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameBranchOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameBranchOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case GameBranchOrderBy.Id: return 'id';
            case GameBranchOrderBy.Title: return 'title';
            case GameBranchOrderBy.BuildId: return 'build_id';
            case GameBranchOrderBy.BuildRev: return 'build_rev';
            case GameBranchOrderBy.BuildTotalSize: return 'build_total_size';
            case GameBranchOrderBy.BuildCompressedSize: return 'build_compressed_size';
            case GameBranchOrderBy.BuildCreatedAt: return 'build_created_at';
            case GameBranchOrderBy.GameEngine: return 'game_engine';
            case GameBranchOrderBy.Platform: return 'platform';
            case GameBranchOrderBy.IsPublic: return 'is_public';
            case GameBranchOrderBy.IsDefault: return 'is_default';
            case GameBranchOrderBy.IsDeleted: return 'is_deleted';
            case GameBranchOrderBy.CreatedAt: return 'created_at';
            case GameBranchOrderBy.UpdatedAt: return 'updated_at';
            default: throw new Error(`Invalid GameBranchOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameBranchOrderBy {
        switch (json) {
            case 'id': return GameBranchOrderBy.Id;
            case 'title': return GameBranchOrderBy.Title;
            case 'build_id': return GameBranchOrderBy.BuildId;
            case 'build_rev': return GameBranchOrderBy.BuildRev;
            case 'build_total_size': return GameBranchOrderBy.BuildTotalSize;
            case 'build_compressed_size': return GameBranchOrderBy.BuildCompressedSize;
            case 'build_created_at': return GameBranchOrderBy.BuildCreatedAt;
            case 'game_engine': return GameBranchOrderBy.GameEngine;
            case 'platform': return GameBranchOrderBy.Platform;
            case 'is_public': return GameBranchOrderBy.IsPublic;
            case 'is_default': return GameBranchOrderBy.IsDefault;
            case 'is_deleted': return GameBranchOrderBy.IsDeleted;
            case 'created_at': return GameBranchOrderBy.CreatedAt;
            case 'updated_at': return GameBranchOrderBy.UpdatedAt;
            default: throw new Error(`Invalid GameBranchOrderBy value: ${json}`);
        }
    }

    export function getDescription(value: GameBranchOrderBy): string {
        switch (value) {
            case GameBranchOrderBy.Id: return '';
            case GameBranchOrderBy.Title: return '';
            case GameBranchOrderBy.BuildId: return '';
            case GameBranchOrderBy.BuildRev: return '';
            case GameBranchOrderBy.BuildTotalSize: return '';
            case GameBranchOrderBy.BuildCompressedSize: return '';
            case GameBranchOrderBy.BuildCreatedAt: return '';
            case GameBranchOrderBy.GameEngine: return '';
            case GameBranchOrderBy.Platform: return '';
            case GameBranchOrderBy.IsPublic: return '';
            case GameBranchOrderBy.IsDefault: return '';
            case GameBranchOrderBy.IsDeleted: return '';
            case GameBranchOrderBy.CreatedAt: return '';
            case GameBranchOrderBy.UpdatedAt: return '';
            default: return '';
        }
    }
}

export class GameBranchCreateRequest {
    title!: string;
    description!: string;
    password!: string;
    gameEngine!: GameEngine;
    platform!: Platform;

    static fromJson(json: Igor.Json.JsonValue): GameBranchCreateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameBranchCreateRequest();
        obj.title = jsonObject['title'] as string;
        obj.description = jsonObject['description'] as string;
        obj.password = jsonObject['password'] as string;
        obj.gameEngine = GameEngine.fromJson(jsonObject['game_engine']);
        obj.platform = Platform.fromJson(jsonObject['platform']);
        return obj;
    }

    static toJson(value: GameBranchCreateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['title'] = value.title;
        result['description'] = value.description;
        result['password'] = value.password;
        result['game_engine'] = GameEngine.toJson(value.gameEngine);
        result['platform'] = Platform.toJson(value.platform);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameBranchCreateRequest.toJson(this);
    }
}

export enum GameBranchCreateError {
    Failure = 1,
    BranchTitleAlreadyExists = 2,
    InvalidGameId = 3,
    InvalidBranchTitle = 4,
    InvalidGameEngine = 5,
    InvalidPlatform = 6,
}

export namespace GameBranchCreateError {
    export function toJson(value: GameBranchCreateError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameBranchCreateError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameBranchCreateError): Igor.Json.JsonValue {
        switch (value) {
            case GameBranchCreateError.Failure: return 'failure';
            case GameBranchCreateError.BranchTitleAlreadyExists: return 'branch_title_already_exists';
            case GameBranchCreateError.InvalidGameId: return 'invalid_game_id';
            case GameBranchCreateError.InvalidBranchTitle: return 'invalid_branch_title';
            case GameBranchCreateError.InvalidGameEngine: return 'invalid_game_engine';
            case GameBranchCreateError.InvalidPlatform: return 'invalid_platform';
            default: throw new Error(`Invalid GameBranchCreateError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameBranchCreateError {
        switch (json) {
            case 'failure': return GameBranchCreateError.Failure;
            case 'branch_title_already_exists': return GameBranchCreateError.BranchTitleAlreadyExists;
            case 'invalid_game_id': return GameBranchCreateError.InvalidGameId;
            case 'invalid_branch_title': return GameBranchCreateError.InvalidBranchTitle;
            case 'invalid_game_engine': return GameBranchCreateError.InvalidGameEngine;
            case 'invalid_platform': return GameBranchCreateError.InvalidPlatform;
            default: throw new Error(`Invalid GameBranchCreateError value: ${json}`);
        }
    }

    export function getDescription(value: GameBranchCreateError): string {
        switch (value) {
            case GameBranchCreateError.Failure: return '';
            case GameBranchCreateError.BranchTitleAlreadyExists: return '';
            case GameBranchCreateError.InvalidGameId: return '';
            case GameBranchCreateError.InvalidBranchTitle: return '';
            case GameBranchCreateError.InvalidGameEngine: return '';
            case GameBranchCreateError.InvalidPlatform: return '';
            default: return '';
        }
    }
}

export class GameBranchCreateResponse implements IResult {
    result!: boolean;
    error?: GameBranchCreateError | null = null;
    branch?: GameBranch | null = null;

    static fromJson(json: Igor.Json.JsonValue): GameBranchCreateResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameBranchCreateResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? GameBranchCreateError.fromJson(jsonObject['error']) : null;
        obj.branch = ('branch' in jsonObject && jsonObject['branch'] != null) ? GameBranch.fromJson(jsonObject['branch']) : null;
        return obj;
    }

    static toJson(value: GameBranchCreateResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = GameBranchCreateError.toJson(value.error);
        if (value.branch != null) result['branch'] = value.branch.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameBranchCreateResponse.toJson(this);
    }
}

export class GameBranchUpdateRequest {
    title?: string | null;
    description?: string | null;
    password?: string | null;
    gameEngine?: GameEngine | null;
    iniConfig?: Array<IniFileEntry> | null;
    registryConfig?: Array<RegistryConfigEntry> | null;
    isReportable?: boolean | null;
    isPublic?: boolean | null;
    isDeleted?: boolean | null;

    static fromJson(json: Igor.Json.JsonValue): GameBranchUpdateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameBranchUpdateRequest();
        if (jsonObject['title'] !== undefined) obj.title = jsonObject['title'] as string;
        if (jsonObject['description'] !== undefined) obj.description = jsonObject['description'] as string;
        if (jsonObject['password'] !== undefined) obj.password = jsonObject['password'] as string;
        if (jsonObject['game_engine'] !== undefined) obj.gameEngine = jsonObject['game_engine'] != null ? GameEngine.fromJson(jsonObject['game_engine']) : null;
        if (jsonObject['ini_config'] !== undefined) obj.iniConfig = jsonObject['ini_config'] != null ? Igor.Json.List(IniFileEntry).fromJson(jsonObject['ini_config']) : null;
        if (jsonObject['registry_config'] !== undefined) obj.registryConfig = jsonObject['registry_config'] != null ? Igor.Json.List(RegistryConfigEntry).fromJson(jsonObject['registry_config']) : null;
        if (jsonObject['is_reportable'] !== undefined) obj.isReportable = jsonObject['is_reportable'] as boolean;
        if (jsonObject['is_public'] !== undefined) obj.isPublic = jsonObject['is_public'] as boolean;
        if (jsonObject['is_deleted'] !== undefined) obj.isDeleted = jsonObject['is_deleted'] as boolean;
        return obj;
    }

    static toJson(value: GameBranchUpdateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.title !== undefined) result['title'] = value.title;
        if (value.description !== undefined) result['description'] = value.description;
        if (value.password !== undefined) result['password'] = value.password;
        if (value.gameEngine !== undefined) result['game_engine'] = value.gameEngine != null ? GameEngine.toJson(value.gameEngine) : null;
        if (value.iniConfig !== undefined) result['ini_config'] = value.iniConfig != null ? Igor.Json.List(IniFileEntry).toJson(value.iniConfig) : null;
        if (value.registryConfig !== undefined) result['registry_config'] = value.registryConfig != null ? Igor.Json.List(RegistryConfigEntry).toJson(value.registryConfig) : null;
        if (value.isReportable !== undefined) result['is_reportable'] = value.isReportable;
        if (value.isPublic !== undefined) result['is_public'] = value.isPublic;
        if (value.isDeleted !== undefined) result['is_deleted'] = value.isDeleted;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameBranchUpdateRequest.toJson(this);
    }
}

export enum GameBranchUpdateError {
    Failure = 1,
    RevMismatch = 2,
    NothingToUpdate = 3,
    BranchTitleAlreadyExists = 4,
    InvalidBranchTitle = 5,
}

export namespace GameBranchUpdateError {
    export function toJson(value: GameBranchUpdateError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameBranchUpdateError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameBranchUpdateError): Igor.Json.JsonValue {
        switch (value) {
            case GameBranchUpdateError.Failure: return 'failure';
            case GameBranchUpdateError.RevMismatch: return 'rev_mismatch';
            case GameBranchUpdateError.NothingToUpdate: return 'nothing_to_update';
            case GameBranchUpdateError.BranchTitleAlreadyExists: return 'branch_title_already_exists';
            case GameBranchUpdateError.InvalidBranchTitle: return 'invalid_branch_title';
            default: throw new Error(`Invalid GameBranchUpdateError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameBranchUpdateError {
        switch (json) {
            case 'failure': return GameBranchUpdateError.Failure;
            case 'rev_mismatch': return GameBranchUpdateError.RevMismatch;
            case 'nothing_to_update': return GameBranchUpdateError.NothingToUpdate;
            case 'branch_title_already_exists': return GameBranchUpdateError.BranchTitleAlreadyExists;
            case 'invalid_branch_title': return GameBranchUpdateError.InvalidBranchTitle;
            default: throw new Error(`Invalid GameBranchUpdateError value: ${json}`);
        }
    }

    export function getDescription(value: GameBranchUpdateError): string {
        switch (value) {
            case GameBranchUpdateError.Failure: return '';
            case GameBranchUpdateError.RevMismatch: return '';
            case GameBranchUpdateError.NothingToUpdate: return '';
            case GameBranchUpdateError.BranchTitleAlreadyExists: return '';
            case GameBranchUpdateError.InvalidBranchTitle: return '';
            default: return '';
        }
    }
}

export class GameBranchUpdateResponse implements IResult {
    result!: boolean;
    error?: GameBranchUpdateError | null = null;
    branch?: GameBranch | null = null;

    static fromJson(json: Igor.Json.JsonValue): GameBranchUpdateResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameBranchUpdateResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? GameBranchUpdateError.fromJson(jsonObject['error']) : null;
        obj.branch = ('branch' in jsonObject && jsonObject['branch'] != null) ? GameBranch.fromJson(jsonObject['branch']) : null;
        return obj;
    }

    static toJson(value: GameBranchUpdateResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = GameBranchUpdateError.toJson(value.error);
        if (value.branch != null) result['branch'] = value.branch.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameBranchUpdateResponse.toJson(this);
    }
}

export class GameBranchBuildRequest {
    buildId!: number;

    static fromJson(json: Igor.Json.JsonValue): GameBranchBuildRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameBranchBuildRequest();
        obj.buildId = jsonObject['build_id'] as number;
        return obj;
    }

    static toJson(value: GameBranchBuildRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['build_id'] = value.buildId;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameBranchBuildRequest.toJson(this);
    }
}

export enum GameBranchBuildError {
    Failure = 1,
    BranchNotExists = 2,
    BuildNotExists = 3,
    BuildIsDraft = 4,
    GameMismatch = 5,
    PlatformMismatch = 6,
}

export namespace GameBranchBuildError {
    export function toJson(value: GameBranchBuildError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameBranchBuildError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameBranchBuildError): Igor.Json.JsonValue {
        switch (value) {
            case GameBranchBuildError.Failure: return 'failure';
            case GameBranchBuildError.BranchNotExists: return 'branch_not_exists';
            case GameBranchBuildError.BuildNotExists: return 'build_not_exists';
            case GameBranchBuildError.BuildIsDraft: return 'build_is_draft';
            case GameBranchBuildError.GameMismatch: return 'game_mismatch';
            case GameBranchBuildError.PlatformMismatch: return 'platform_mismatch';
            default: throw new Error(`Invalid GameBranchBuildError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameBranchBuildError {
        switch (json) {
            case 'failure': return GameBranchBuildError.Failure;
            case 'branch_not_exists': return GameBranchBuildError.BranchNotExists;
            case 'build_not_exists': return GameBranchBuildError.BuildNotExists;
            case 'build_is_draft': return GameBranchBuildError.BuildIsDraft;
            case 'game_mismatch': return GameBranchBuildError.GameMismatch;
            case 'platform_mismatch': return GameBranchBuildError.PlatformMismatch;
            default: throw new Error(`Invalid GameBranchBuildError value: ${json}`);
        }
    }

    export function getDescription(value: GameBranchBuildError): string {
        switch (value) {
            case GameBranchBuildError.Failure: return '';
            case GameBranchBuildError.BranchNotExists: return '';
            case GameBranchBuildError.BuildNotExists: return '';
            case GameBranchBuildError.BuildIsDraft: return '';
            case GameBranchBuildError.GameMismatch: return '';
            case GameBranchBuildError.PlatformMismatch: return '';
            default: return '';
        }
    }
}

export class GameBranchBuildResponse implements IResult {
    result!: boolean;
    error?: GameBranchBuildError | null = null;
    branch?: GameBranch | null = null;

    static fromJson(json: Igor.Json.JsonValue): GameBranchBuildResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameBranchBuildResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? GameBranchBuildError.fromJson(jsonObject['error']) : null;
        obj.branch = ('branch' in jsonObject && jsonObject['branch'] != null) ? GameBranch.fromJson(jsonObject['branch']) : null;
        return obj;
    }

    static toJson(value: GameBranchBuildResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = GameBranchBuildError.toJson(value.error);
        if (value.branch != null) result['branch'] = value.branch.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameBranchBuildResponse.toJson(this);
    }
}

export class GameCategory {
    id!: number;
    rev!: number;
    name!: string;
    description!: string;
    sortOrder!: number;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): GameCategory {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameCategory();
        obj.id = jsonObject['id'] as number;
        obj.rev = jsonObject['rev'] as number;
        obj.name = jsonObject['name'] as string;
        obj.description = jsonObject['description'] as string;
        obj.sortOrder = jsonObject['sort_order'] as number;
        obj.createdAt = Igor.Json.DateSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: GameCategory): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['rev'] = value.rev;
        result['name'] = value.name;
        result['description'] = value.description;
        result['sort_order'] = value.sortOrder;
        result['created_at'] = Igor.Json.DateSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameCategory.toJson(this);
    }
}

export class GameCategoryExcerpt {
    id!: number;
    name!: string;
    description!: string;
    sortOrder!: number;

    static fromJson(json: Igor.Json.JsonValue): GameCategoryExcerpt {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameCategoryExcerpt();
        obj.id = jsonObject['id'] as number;
        obj.name = jsonObject['name'] as string;
        obj.description = jsonObject['description'] as string;
        obj.sortOrder = jsonObject['sort_order'] as number;
        return obj;
    }

    static toJson(value: GameCategoryExcerpt): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['name'] = value.name;
        result['description'] = value.description;
        result['sort_order'] = value.sortOrder;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameCategoryExcerpt.toJson(this);
    }
}

export enum GameCategoryManageError {
    Failure = 1,
    AlreadyExists = 2,
    InvalidName = 3,
}

export namespace GameCategoryManageError {
    export function toJson(value: GameCategoryManageError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): GameCategoryManageError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: GameCategoryManageError): Igor.Json.JsonValue {
        switch (value) {
            case GameCategoryManageError.Failure: return 'failure';
            case GameCategoryManageError.AlreadyExists: return 'already_exists';
            case GameCategoryManageError.InvalidName: return 'invalid_name';
            default: throw new Error(`Invalid GameCategoryManageError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): GameCategoryManageError {
        switch (json) {
            case 'failure': return GameCategoryManageError.Failure;
            case 'already_exists': return GameCategoryManageError.AlreadyExists;
            case 'invalid_name': return GameCategoryManageError.InvalidName;
            default: throw new Error(`Invalid GameCategoryManageError value: ${json}`);
        }
    }

    export function getDescription(value: GameCategoryManageError): string {
        switch (value) {
            case GameCategoryManageError.Failure: return '';
            case GameCategoryManageError.AlreadyExists: return '';
            case GameCategoryManageError.InvalidName: return '';
            default: return '';
        }
    }
}

export class GameCategoryManageResponse implements IResult {
    result!: boolean;
    error?: GameCategoryManageError | null = null;
    category?: GameCategory | null = null;

    static fromJson(json: Igor.Json.JsonValue): GameCategoryManageResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameCategoryManageResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? GameCategoryManageError.fromJson(jsonObject['error']) : null;
        obj.category = ('category' in jsonObject && jsonObject['category'] != null) ? GameCategory.fromJson(jsonObject['category']) : null;
        return obj;
    }

    static toJson(value: GameCategoryManageResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = GameCategoryManageError.toJson(value.error);
        if (value.category != null) result['category'] = value.category.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameCategoryManageResponse.toJson(this);
    }
}

export class GameCategoryCreateRequest {
    name!: string;
    description!: string;
    sortOrder!: number;

    static fromJson(json: Igor.Json.JsonValue): GameCategoryCreateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameCategoryCreateRequest();
        obj.name = jsonObject['name'] as string;
        obj.description = jsonObject['description'] as string;
        obj.sortOrder = jsonObject['sort_order'] as number;
        return obj;
    }

    static toJson(value: GameCategoryCreateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['name'] = value.name;
        result['description'] = value.description;
        result['sort_order'] = value.sortOrder;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameCategoryCreateRequest.toJson(this);
    }
}

export class GameCategoryUpdateRequest {
    name?: string | null = null;
    description?: string | null = null;
    sortOrder?: number | null = null;

    static fromJson(json: Igor.Json.JsonValue): GameCategoryUpdateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameCategoryUpdateRequest();
        obj.name = ('name' in jsonObject && jsonObject['name'] != null) ? jsonObject['name'] as string : null;
        obj.description = ('description' in jsonObject && jsonObject['description'] != null) ? jsonObject['description'] as string : null;
        obj.sortOrder = ('sort_order' in jsonObject && jsonObject['sort_order'] != null) ? jsonObject['sort_order'] as number : null;
        return obj;
    }

    static toJson(value: GameCategoryUpdateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.name != null) result['name'] = value.name;
        if (value.description != null) result['description'] = value.description;
        if (value.sortOrder != null) result['sort_order'] = value.sortOrder;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameCategoryUpdateRequest.toJson(this);
    }
}

export class GameCategoryExcerptList {
    categories: Array<GameCategoryExcerpt> = [];

    static fromJson(json: Igor.Json.JsonValue): GameCategoryExcerptList {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new GameCategoryExcerptList();
        obj.categories = ('categories' in jsonObject && jsonObject['categories'] != null) ? Igor.Json.List(GameCategoryExcerpt).fromJson(jsonObject['categories']) : [];
        return obj;
    }

    static toJson(value: GameCategoryExcerptList): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['categories'] = Igor.Json.List(GameCategoryExcerpt).toJson(value.categories);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return GameCategoryExcerptList.toJson(this);
    }
}

export class ClientAccount {
    id!: number;
    rev!: number;
    username!: string;
    email!: string;
    phone?: string | null = null;
    isActivated!: boolean;
    isBlocked!: boolean;
    isDeleted!: boolean;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): ClientAccount {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new ClientAccount();
        obj.id = jsonObject['id'] as number;
        obj.rev = jsonObject['rev'] as number;
        obj.username = jsonObject['username'] as string;
        obj.email = jsonObject['email'] as string;
        obj.phone = ('phone' in jsonObject && jsonObject['phone'] != null) ? jsonObject['phone'] as string : null;
        obj.isActivated = jsonObject['is_activated'] as boolean;
        obj.isBlocked = jsonObject['is_blocked'] as boolean;
        obj.isDeleted = jsonObject['is_deleted'] as boolean;
        obj.createdAt = Igor.Json.DateSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: ClientAccount): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['rev'] = value.rev;
        result['username'] = value.username;
        result['email'] = value.email;
        if (value.phone != null) result['phone'] = value.phone;
        result['is_activated'] = value.isActivated;
        result['is_blocked'] = value.isBlocked;
        result['is_deleted'] = value.isDeleted;
        result['created_at'] = Igor.Json.DateSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return ClientAccount.toJson(this);
    }
}

export enum ClientAccountOrderBy {
    Id = 1,
    Username = 2,
    Email = 3,
    IsActivated = 4,
    IsBlocked = 5,
    IsDeleted = 6,
    CreatedAt = 7,
    UpdatedAt = 8,
}

export namespace ClientAccountOrderBy {
    export function toJson(value: ClientAccountOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): ClientAccountOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: ClientAccountOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case ClientAccountOrderBy.Id: return 'id';
            case ClientAccountOrderBy.Username: return 'username';
            case ClientAccountOrderBy.Email: return 'email';
            case ClientAccountOrderBy.IsActivated: return 'is_activated';
            case ClientAccountOrderBy.IsBlocked: return 'is_blocked';
            case ClientAccountOrderBy.IsDeleted: return 'is_deleted';
            case ClientAccountOrderBy.CreatedAt: return 'created_at';
            case ClientAccountOrderBy.UpdatedAt: return 'updated_at';
            default: throw new Error(`Invalid ClientAccountOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): ClientAccountOrderBy {
        switch (json) {
            case 'id': return ClientAccountOrderBy.Id;
            case 'username': return ClientAccountOrderBy.Username;
            case 'email': return ClientAccountOrderBy.Email;
            case 'is_activated': return ClientAccountOrderBy.IsActivated;
            case 'is_blocked': return ClientAccountOrderBy.IsBlocked;
            case 'is_deleted': return ClientAccountOrderBy.IsDeleted;
            case 'created_at': return ClientAccountOrderBy.CreatedAt;
            case 'updated_at': return ClientAccountOrderBy.UpdatedAt;
            default: throw new Error(`Invalid ClientAccountOrderBy value: ${json}`);
        }
    }

    export function getDescription(value: ClientAccountOrderBy): string {
        switch (value) {
            case ClientAccountOrderBy.Id: return '';
            case ClientAccountOrderBy.Username: return '';
            case ClientAccountOrderBy.Email: return '';
            case ClientAccountOrderBy.IsActivated: return '';
            case ClientAccountOrderBy.IsBlocked: return '';
            case ClientAccountOrderBy.IsDeleted: return '';
            case ClientAccountOrderBy.CreatedAt: return '';
            case ClientAccountOrderBy.UpdatedAt: return '';
            default: return '';
        }
    }
}

export class PersonnelAccount {
    id!: number;
    rev!: number;
    username!: string;
    name?: string | null = null;
    email?: string | null = null;
    phone?: string | null = null;
    isBlocked!: boolean;
    isDeleted!: boolean;
    isSuperadmin!: boolean;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): PersonnelAccount {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PersonnelAccount();
        obj.id = jsonObject['id'] as number;
        obj.rev = jsonObject['rev'] as number;
        obj.username = jsonObject['username'] as string;
        obj.name = ('name' in jsonObject && jsonObject['name'] != null) ? jsonObject['name'] as string : null;
        obj.email = ('email' in jsonObject && jsonObject['email'] != null) ? jsonObject['email'] as string : null;
        obj.phone = ('phone' in jsonObject && jsonObject['phone'] != null) ? jsonObject['phone'] as string : null;
        obj.isBlocked = jsonObject['is_blocked'] as boolean;
        obj.isDeleted = jsonObject['is_deleted'] as boolean;
        obj.isSuperadmin = jsonObject['is_superadmin'] as boolean;
        obj.createdAt = Igor.Json.DateSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: PersonnelAccount): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['rev'] = value.rev;
        result['username'] = value.username;
        if (value.name != null) result['name'] = value.name;
        if (value.email != null) result['email'] = value.email;
        if (value.phone != null) result['phone'] = value.phone;
        result['is_blocked'] = value.isBlocked;
        result['is_deleted'] = value.isDeleted;
        result['is_superadmin'] = value.isSuperadmin;
        result['created_at'] = Igor.Json.DateSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PersonnelAccount.toJson(this);
    }
}

export enum PersonnelAccountOrderBy {
    Id = 1,
    Username = 2,
    Email = 3,
    IsBlocked = 4,
    IsDeleted = 5,
    CreatedAt = 6,
    UpdatedAt = 7,
}

export namespace PersonnelAccountOrderBy {
    export function toJson(value: PersonnelAccountOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): PersonnelAccountOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: PersonnelAccountOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case PersonnelAccountOrderBy.Id: return 'id';
            case PersonnelAccountOrderBy.Username: return 'username';
            case PersonnelAccountOrderBy.Email: return 'email';
            case PersonnelAccountOrderBy.IsBlocked: return 'is_blocked';
            case PersonnelAccountOrderBy.IsDeleted: return 'is_deleted';
            case PersonnelAccountOrderBy.CreatedAt: return 'created_at';
            case PersonnelAccountOrderBy.UpdatedAt: return 'updated_at';
            default: throw new Error(`Invalid PersonnelAccountOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): PersonnelAccountOrderBy {
        switch (json) {
            case 'id': return PersonnelAccountOrderBy.Id;
            case 'username': return PersonnelAccountOrderBy.Username;
            case 'email': return PersonnelAccountOrderBy.Email;
            case 'is_blocked': return PersonnelAccountOrderBy.IsBlocked;
            case 'is_deleted': return PersonnelAccountOrderBy.IsDeleted;
            case 'created_at': return PersonnelAccountOrderBy.CreatedAt;
            case 'updated_at': return PersonnelAccountOrderBy.UpdatedAt;
            default: throw new Error(`Invalid PersonnelAccountOrderBy value: ${json}`);
        }
    }

    export function getDescription(value: PersonnelAccountOrderBy): string {
        switch (value) {
            case PersonnelAccountOrderBy.Id: return '';
            case PersonnelAccountOrderBy.Username: return '';
            case PersonnelAccountOrderBy.Email: return '';
            case PersonnelAccountOrderBy.IsBlocked: return '';
            case PersonnelAccountOrderBy.IsDeleted: return '';
            case PersonnelAccountOrderBy.CreatedAt: return '';
            case PersonnelAccountOrderBy.UpdatedAt: return '';
            default: return '';
        }
    }
}

export class PersonnelAccountProfile {
    id!: number;
    rev!: number;
    username!: string;
    name?: string | null = null;
    email?: string | null = null;
    phone?: string | null = null;
    apiKey?: string | null = null;
    isBlocked!: boolean;
    isDeleted!: boolean;
    isGameManager!: boolean;
    isSuperadmin!: boolean;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): PersonnelAccountProfile {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PersonnelAccountProfile();
        obj.id = jsonObject['id'] as number;
        obj.rev = jsonObject['rev'] as number;
        obj.username = jsonObject['username'] as string;
        obj.name = ('name' in jsonObject && jsonObject['name'] != null) ? jsonObject['name'] as string : null;
        obj.email = ('email' in jsonObject && jsonObject['email'] != null) ? jsonObject['email'] as string : null;
        obj.phone = ('phone' in jsonObject && jsonObject['phone'] != null) ? jsonObject['phone'] as string : null;
        obj.apiKey = ('api_key' in jsonObject && jsonObject['api_key'] != null) ? jsonObject['api_key'] as string : null;
        obj.isBlocked = jsonObject['is_blocked'] as boolean;
        obj.isDeleted = jsonObject['is_deleted'] as boolean;
        obj.isGameManager = jsonObject['is_game_manager'] as boolean;
        obj.isSuperadmin = jsonObject['is_superadmin'] as boolean;
        obj.createdAt = Igor.Json.DateSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: PersonnelAccountProfile): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['rev'] = value.rev;
        result['username'] = value.username;
        if (value.name != null) result['name'] = value.name;
        if (value.email != null) result['email'] = value.email;
        if (value.phone != null) result['phone'] = value.phone;
        if (value.apiKey != null) result['api_key'] = value.apiKey;
        result['is_blocked'] = value.isBlocked;
        result['is_deleted'] = value.isDeleted;
        result['is_game_manager'] = value.isGameManager;
        result['is_superadmin'] = value.isSuperadmin;
        result['created_at'] = Igor.Json.DateSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PersonnelAccountProfile.toJson(this);
    }
}

export class PersonnelApiKeyUpdateResponse {
    apiKey!: string;

    static fromJson(json: Igor.Json.JsonValue): PersonnelApiKeyUpdateResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PersonnelApiKeyUpdateResponse();
        obj.apiKey = jsonObject['api_key'] as string;
        return obj;
    }

    static toJson(value: PersonnelApiKeyUpdateResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['api_key'] = value.apiKey;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PersonnelApiKeyUpdateResponse.toJson(this);
    }
}

export class PersonnelGroup {
    id!: number;
    rev!: number;
    name!: string;
    description?: string | null = null;
    isDeleted!: boolean;
    members!: Array<string>;
    memberCount!: number;
    isSuperadmin!: boolean;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): PersonnelGroup {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PersonnelGroup();
        obj.id = jsonObject['id'] as number;
        obj.rev = jsonObject['rev'] as number;
        obj.name = jsonObject['name'] as string;
        obj.description = ('description' in jsonObject && jsonObject['description'] != null) ? jsonObject['description'] as string : null;
        obj.isDeleted = jsonObject['is_deleted'] as boolean;
        obj.members = Igor.Json.List(Igor.Json.String).fromJson(jsonObject['members']);
        obj.memberCount = jsonObject['member_count'] as number;
        obj.isSuperadmin = jsonObject['is_superadmin'] as boolean;
        obj.createdAt = Igor.Json.DateSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: PersonnelGroup): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['rev'] = value.rev;
        result['name'] = value.name;
        if (value.description != null) result['description'] = value.description;
        result['is_deleted'] = value.isDeleted;
        result['members'] = Igor.Json.List(Igor.Json.String).toJson(value.members);
        result['member_count'] = value.memberCount;
        result['is_superadmin'] = value.isSuperadmin;
        result['created_at'] = Igor.Json.DateSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PersonnelGroup.toJson(this);
    }
}

export enum PersonnelGroupOrderBy {
    Id = 1,
    Name = 2,
    IsDeleted = 3,
    MemberCount = 4,
    CreatedAt = 5,
    UpdatedAt = 6,
}

export namespace PersonnelGroupOrderBy {
    export function toJson(value: PersonnelGroupOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): PersonnelGroupOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: PersonnelGroupOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case PersonnelGroupOrderBy.Id: return 'id';
            case PersonnelGroupOrderBy.Name: return 'name';
            case PersonnelGroupOrderBy.IsDeleted: return 'is_deleted';
            case PersonnelGroupOrderBy.MemberCount: return 'member_count';
            case PersonnelGroupOrderBy.CreatedAt: return 'created_at';
            case PersonnelGroupOrderBy.UpdatedAt: return 'updated_at';
            default: throw new Error(`Invalid PersonnelGroupOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): PersonnelGroupOrderBy {
        switch (json) {
            case 'id': return PersonnelGroupOrderBy.Id;
            case 'name': return PersonnelGroupOrderBy.Name;
            case 'is_deleted': return PersonnelGroupOrderBy.IsDeleted;
            case 'member_count': return PersonnelGroupOrderBy.MemberCount;
            case 'created_at': return PersonnelGroupOrderBy.CreatedAt;
            case 'updated_at': return PersonnelGroupOrderBy.UpdatedAt;
            default: throw new Error(`Invalid PersonnelGroupOrderBy value: ${json}`);
        }
    }

    export function getDescription(value: PersonnelGroupOrderBy): string {
        switch (value) {
            case PersonnelGroupOrderBy.Id: return '';
            case PersonnelGroupOrderBy.Name: return '';
            case PersonnelGroupOrderBy.IsDeleted: return '';
            case PersonnelGroupOrderBy.MemberCount: return '';
            case PersonnelGroupOrderBy.CreatedAt: return '';
            case PersonnelGroupOrderBy.UpdatedAt: return '';
            default: return '';
        }
    }
}

export class PersonnelAccountRole {
    personnelId!: number;
    username!: string;
    gameId!: string;
    gameTitle!: string;
    gameBranches!: Igor.Json.JsonValue;
    groupRoles?: Igor.Json.JsonValue | null = null;
    userRole?: AccessRole | null = null;
    isGlobal?: boolean | null = null;
    branchIds?: Array<number> | null = null;

    static fromJson(json: Igor.Json.JsonValue): PersonnelAccountRole {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PersonnelAccountRole();
        obj.personnelId = jsonObject['personnel_id'] as number;
        obj.username = jsonObject['username'] as string;
        obj.gameId = jsonObject['game_id'] as string;
        obj.gameTitle = jsonObject['game_title'] as string;
        obj.gameBranches = jsonObject['game_branches'];
        obj.groupRoles = ('group_roles' in jsonObject && jsonObject['group_roles'] != null) ? jsonObject['group_roles'] : null;
        obj.userRole = ('user_role' in jsonObject && jsonObject['user_role'] != null) ? AccessRole.fromJson(jsonObject['user_role']) : null;
        obj.isGlobal = ('is_global' in jsonObject && jsonObject['is_global'] != null) ? jsonObject['is_global'] as boolean : null;
        obj.branchIds = ('branch_ids' in jsonObject && jsonObject['branch_ids'] != null) ? Igor.Json.List(Igor.Json.Number).fromJson(jsonObject['branch_ids']) : null;
        return obj;
    }

    static toJson(value: PersonnelAccountRole): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['personnel_id'] = value.personnelId;
        result['username'] = value.username;
        result['game_id'] = value.gameId;
        result['game_title'] = value.gameTitle;
        result['game_branches'] = value.gameBranches;
        if (value.groupRoles != null) result['group_roles'] = value.groupRoles;
        if (value.userRole != null) result['user_role'] = AccessRole.toJson(value.userRole);
        if (value.isGlobal != null) result['is_global'] = value.isGlobal;
        if (value.branchIds != null) result['branch_ids'] = Igor.Json.List(Igor.Json.Number).toJson(value.branchIds);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PersonnelAccountRole.toJson(this);
    }
}

export enum PersonnelAccountRoleOrderBy {
    PersonnelId = 1,
    Username = 2,
    GameId = 3,
    GameTitle = 4,
    UserRole = 5,
}

export namespace PersonnelAccountRoleOrderBy {
    export function toJson(value: PersonnelAccountRoleOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): PersonnelAccountRoleOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: PersonnelAccountRoleOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case PersonnelAccountRoleOrderBy.PersonnelId: return 'personnel_id';
            case PersonnelAccountRoleOrderBy.Username: return 'username';
            case PersonnelAccountRoleOrderBy.GameId: return 'game_id';
            case PersonnelAccountRoleOrderBy.GameTitle: return 'game_title';
            case PersonnelAccountRoleOrderBy.UserRole: return 'user_role';
            default: throw new Error(`Invalid PersonnelAccountRoleOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): PersonnelAccountRoleOrderBy {
        switch (json) {
            case 'personnel_id': return PersonnelAccountRoleOrderBy.PersonnelId;
            case 'username': return PersonnelAccountRoleOrderBy.Username;
            case 'game_id': return PersonnelAccountRoleOrderBy.GameId;
            case 'game_title': return PersonnelAccountRoleOrderBy.GameTitle;
            case 'user_role': return PersonnelAccountRoleOrderBy.UserRole;
            default: throw new Error(`Invalid PersonnelAccountRoleOrderBy value: ${json}`);
        }
    }

    export function getDescription(value: PersonnelAccountRoleOrderBy): string {
        switch (value) {
            case PersonnelAccountRoleOrderBy.PersonnelId: return '';
            case PersonnelAccountRoleOrderBy.Username: return '';
            case PersonnelAccountRoleOrderBy.GameId: return '';
            case PersonnelAccountRoleOrderBy.GameTitle: return '';
            case PersonnelAccountRoleOrderBy.UserRole: return '';
            default: return '';
        }
    }
}

export class PersonnelGroupRole {
    groupId!: number;
    groupName!: string;
    gameId!: string;
    gameTitle!: string;
    gameBranches!: Igor.Json.JsonValue;
    groupRole?: AccessRole | null = null;
    isGlobal?: boolean | null = null;
    branchIds?: Array<number> | null = null;

    static fromJson(json: Igor.Json.JsonValue): PersonnelGroupRole {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PersonnelGroupRole();
        obj.groupId = jsonObject['group_id'] as number;
        obj.groupName = jsonObject['group_name'] as string;
        obj.gameId = jsonObject['game_id'] as string;
        obj.gameTitle = jsonObject['game_title'] as string;
        obj.gameBranches = jsonObject['game_branches'];
        obj.groupRole = ('group_role' in jsonObject && jsonObject['group_role'] != null) ? AccessRole.fromJson(jsonObject['group_role']) : null;
        obj.isGlobal = ('is_global' in jsonObject && jsonObject['is_global'] != null) ? jsonObject['is_global'] as boolean : null;
        obj.branchIds = ('branch_ids' in jsonObject && jsonObject['branch_ids'] != null) ? Igor.Json.List(Igor.Json.Number).fromJson(jsonObject['branch_ids']) : null;
        return obj;
    }

    static toJson(value: PersonnelGroupRole): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['group_id'] = value.groupId;
        result['group_name'] = value.groupName;
        result['game_id'] = value.gameId;
        result['game_title'] = value.gameTitle;
        result['game_branches'] = value.gameBranches;
        if (value.groupRole != null) result['group_role'] = AccessRole.toJson(value.groupRole);
        if (value.isGlobal != null) result['is_global'] = value.isGlobal;
        if (value.branchIds != null) result['branch_ids'] = Igor.Json.List(Igor.Json.Number).toJson(value.branchIds);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PersonnelGroupRole.toJson(this);
    }
}

export enum PersonnelGroupRoleOrderBy {
    GroupId = 1,
    GroupName = 2,
    GameId = 3,
    GameTitle = 4,
    GroupRole = 5,
}

export namespace PersonnelGroupRoleOrderBy {
    export function toJson(value: PersonnelGroupRoleOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): PersonnelGroupRoleOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: PersonnelGroupRoleOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case PersonnelGroupRoleOrderBy.GroupId: return 'group_id';
            case PersonnelGroupRoleOrderBy.GroupName: return 'group_name';
            case PersonnelGroupRoleOrderBy.GameId: return 'game_id';
            case PersonnelGroupRoleOrderBy.GameTitle: return 'game_title';
            case PersonnelGroupRoleOrderBy.GroupRole: return 'group_role';
            default: throw new Error(`Invalid PersonnelGroupRoleOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): PersonnelGroupRoleOrderBy {
        switch (json) {
            case 'group_id': return PersonnelGroupRoleOrderBy.GroupId;
            case 'group_name': return PersonnelGroupRoleOrderBy.GroupName;
            case 'game_id': return PersonnelGroupRoleOrderBy.GameId;
            case 'game_title': return PersonnelGroupRoleOrderBy.GameTitle;
            case 'group_role': return PersonnelGroupRoleOrderBy.GroupRole;
            default: throw new Error(`Invalid PersonnelGroupRoleOrderBy value: ${json}`);
        }
    }

    export function getDescription(value: PersonnelGroupRoleOrderBy): string {
        switch (value) {
            case PersonnelGroupRoleOrderBy.GroupId: return '';
            case PersonnelGroupRoleOrderBy.GroupName: return '';
            case PersonnelGroupRoleOrderBy.GameId: return '';
            case PersonnelGroupRoleOrderBy.GameTitle: return '';
            case PersonnelGroupRoleOrderBy.GroupRole: return '';
            default: return '';
        }
    }
}

export class AccessRoleUpdateRequest {
    role!: AccessRole;
    isGlobal?: boolean | null = null;
    branchIds?: Array<number> | null = null;

    static fromJson(json: Igor.Json.JsonValue): AccessRoleUpdateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new AccessRoleUpdateRequest();
        obj.role = AccessRole.fromJson(jsonObject['role']);
        obj.isGlobal = ('is_global' in jsonObject && jsonObject['is_global'] != null) ? jsonObject['is_global'] as boolean : null;
        obj.branchIds = ('branch_ids' in jsonObject && jsonObject['branch_ids'] != null) ? Igor.Json.List(Igor.Json.Number).fromJson(jsonObject['branch_ids']) : null;
        return obj;
    }

    static toJson(value: AccessRoleUpdateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['role'] = AccessRole.toJson(value.role);
        if (value.isGlobal != null) result['is_global'] = value.isGlobal;
        if (value.branchIds != null) result['branch_ids'] = Igor.Json.List(Igor.Json.Number).toJson(value.branchIds);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return AccessRoleUpdateRequest.toJson(this);
    }
}

export class Settings {
    personnelSessionDuration!: number;
    clientSessionDuration!: number;
    registerConfirmCodeLifetime!: number;
    phoneConfirmCodeLifetime!: number;
    passwordResetConfirmCodeLifetime!: number;
    ciApiKey?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): Settings {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Settings();
        obj.personnelSessionDuration = jsonObject['personnel_session_duration'] as number;
        obj.clientSessionDuration = jsonObject['client_session_duration'] as number;
        obj.registerConfirmCodeLifetime = jsonObject['register_confirm_code_lifetime'] as number;
        obj.phoneConfirmCodeLifetime = jsonObject['phone_confirm_code_lifetime'] as number;
        obj.passwordResetConfirmCodeLifetime = jsonObject['password_reset_confirm_code_lifetime'] as number;
        obj.ciApiKey = ('ci_api_key' in jsonObject && jsonObject['ci_api_key'] != null) ? jsonObject['ci_api_key'] as string : null;
        return obj;
    }

    static toJson(value: Settings): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['personnel_session_duration'] = value.personnelSessionDuration;
        result['client_session_duration'] = value.clientSessionDuration;
        result['register_confirm_code_lifetime'] = value.registerConfirmCodeLifetime;
        result['phone_confirm_code_lifetime'] = value.phoneConfirmCodeLifetime;
        result['password_reset_confirm_code_lifetime'] = value.passwordResetConfirmCodeLifetime;
        if (value.ciApiKey != null) result['ci_api_key'] = value.ciApiKey;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return Settings.toJson(this);
    }
}

export class SettingsUpdateRequest {
    personnelSessionDuration!: number;
    clientSessionDuration!: number;
    registerConfirmCodeLifetime!: number;
    phoneConfirmCodeLifetime!: number;
    passwordResetConfirmCodeLifetime!: number;

    static fromJson(json: Igor.Json.JsonValue): SettingsUpdateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new SettingsUpdateRequest();
        if (jsonObject['personnel_session_duration'] !== undefined) obj.personnelSessionDuration = jsonObject['personnel_session_duration'] as number;
        if (jsonObject['client_session_duration'] !== undefined) obj.clientSessionDuration = jsonObject['client_session_duration'] as number;
        if (jsonObject['register_confirm_code_lifetime'] !== undefined) obj.registerConfirmCodeLifetime = jsonObject['register_confirm_code_lifetime'] as number;
        if (jsonObject['phone_confirm_code_lifetime'] !== undefined) obj.phoneConfirmCodeLifetime = jsonObject['phone_confirm_code_lifetime'] as number;
        if (jsonObject['password_reset_confirm_code_lifetime'] !== undefined) obj.passwordResetConfirmCodeLifetime = jsonObject['password_reset_confirm_code_lifetime'] as number;
        return obj;
    }

    static toJson(value: SettingsUpdateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.personnelSessionDuration !== undefined) result['personnel_session_duration'] = value.personnelSessionDuration;
        if (value.clientSessionDuration !== undefined) result['client_session_duration'] = value.clientSessionDuration;
        if (value.registerConfirmCodeLifetime !== undefined) result['register_confirm_code_lifetime'] = value.registerConfirmCodeLifetime;
        if (value.phoneConfirmCodeLifetime !== undefined) result['phone_confirm_code_lifetime'] = value.phoneConfirmCodeLifetime;
        if (value.passwordResetConfirmCodeLifetime !== undefined) result['password_reset_confirm_code_lifetime'] = value.passwordResetConfirmCodeLifetime;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return SettingsUpdateRequest.toJson(this);
    }
}

export class RegenerateCiApiKeyResponse {
    ciApiKey?: string | null = null;

    static fromJson(json: Igor.Json.JsonValue): RegenerateCiApiKeyResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new RegenerateCiApiKeyResponse();
        obj.ciApiKey = ('ci_api_key' in jsonObject && jsonObject['ci_api_key'] != null) ? jsonObject['ci_api_key'] as string : null;
        return obj;
    }

    static toJson(value: RegenerateCiApiKeyResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.ciApiKey != null) result['ci_api_key'] = value.ciApiKey;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return RegenerateCiApiKeyResponse.toJson(this);
    }
}

export class Build {
    id!: number;
    rev!: number;
    gameId!: string;
    gameTitle!: string;
    branchTags!: Array<string>;
    buildRev!: string;
    commentary!: string;
    changeList!: string;
    totalSize!: number;
    compressedSize!: number;
    exePath!: string;
    logPath!: string;
    crashReportPath!: string;
    configPath!: string;
    optionalFileMasks: Array<string> = [];
    preservedFileMasks: Array<string> = [];
    redistributables: Array<RedistributableEntry> = [];
    pdbFiles: Array<string> = [];
    cdnRootUrl!: string;
    platform!: Platform;
    isPermanent!: boolean;
    isDraft!: boolean;
    isProcessing!: boolean;
    archivedSize!: number;
    processedSize!: number;
    isDeleted!: boolean;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): Build {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new Build();
        obj.id = jsonObject['id'] as number;
        obj.rev = jsonObject['rev'] as number;
        obj.gameId = jsonObject['game_id'] as string;
        obj.gameTitle = jsonObject['game_title'] as string;
        obj.branchTags = Igor.Json.List(Igor.Json.String).fromJson(jsonObject['branch_tags']);
        obj.buildRev = jsonObject['build_rev'] as string;
        obj.commentary = jsonObject['commentary'] as string;
        obj.changeList = jsonObject['change_list'] as string;
        obj.totalSize = jsonObject['total_size'] as number;
        obj.compressedSize = jsonObject['compressed_size'] as number;
        obj.exePath = jsonObject['exe_path'] as string;
        obj.logPath = jsonObject['log_path'] as string;
        obj.crashReportPath = jsonObject['crash_report_path'] as string;
        obj.configPath = jsonObject['config_path'] as string;
        obj.optionalFileMasks = ('optional_file_masks' in jsonObject && jsonObject['optional_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['optional_file_masks']) : [];
        obj.preservedFileMasks = ('preserved_file_masks' in jsonObject && jsonObject['preserved_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['preserved_file_masks']) : [];
        obj.redistributables = ('redistributables' in jsonObject && jsonObject['redistributables'] != null) ? Igor.Json.List(RedistributableEntry).fromJson(jsonObject['redistributables']) : [];
        obj.pdbFiles = ('pdb_files' in jsonObject && jsonObject['pdb_files'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['pdb_files']) : [];
        obj.cdnRootUrl = jsonObject['cdn_root_url'] as string;
        obj.platform = Platform.fromJson(jsonObject['platform']);
        obj.isPermanent = jsonObject['is_permanent'] as boolean;
        obj.isDraft = jsonObject['is_draft'] as boolean;
        obj.isProcessing = jsonObject['is_processing'] as boolean;
        obj.archivedSize = jsonObject['archived_size'] as number;
        obj.processedSize = jsonObject['processed_size'] as number;
        obj.isDeleted = jsonObject['is_deleted'] as boolean;
        obj.createdAt = Igor.Json.DateSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: Build): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['rev'] = value.rev;
        result['game_id'] = value.gameId;
        result['game_title'] = value.gameTitle;
        result['branch_tags'] = Igor.Json.List(Igor.Json.String).toJson(value.branchTags);
        result['build_rev'] = value.buildRev;
        result['commentary'] = value.commentary;
        result['change_list'] = value.changeList;
        result['total_size'] = value.totalSize;
        result['compressed_size'] = value.compressedSize;
        result['exe_path'] = value.exePath;
        result['log_path'] = value.logPath;
        result['crash_report_path'] = value.crashReportPath;
        result['config_path'] = value.configPath;
        result['optional_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.optionalFileMasks);
        result['preserved_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.preservedFileMasks);
        result['redistributables'] = Igor.Json.List(RedistributableEntry).toJson(value.redistributables);
        result['pdb_files'] = Igor.Json.List(Igor.Json.String).toJson(value.pdbFiles);
        result['cdn_root_url'] = value.cdnRootUrl;
        result['platform'] = Platform.toJson(value.platform);
        result['is_permanent'] = value.isPermanent;
        result['is_draft'] = value.isDraft;
        result['is_processing'] = value.isProcessing;
        result['archived_size'] = value.archivedSize;
        result['processed_size'] = value.processedSize;
        result['is_deleted'] = value.isDeleted;
        result['created_at'] = Igor.Json.DateSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return Build.toJson(this);
    }
}

export enum BuildOrderBy {
    Id = 1,
    GameId = 2,
    GameTitle = 3,
    BuildRev = 4,
    TotalSize = 5,
    CompressedSize = 6,
    IsDraft = 7,
    IsDeleted = 8,
    CreatedAt = 9,
    UpdatedAt = 10,
}

export namespace BuildOrderBy {
    export function toJson(value: BuildOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): BuildOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: BuildOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case BuildOrderBy.Id: return 'id';
            case BuildOrderBy.GameId: return 'game_id';
            case BuildOrderBy.GameTitle: return 'game_title';
            case BuildOrderBy.BuildRev: return 'build_rev';
            case BuildOrderBy.TotalSize: return 'total_size';
            case BuildOrderBy.CompressedSize: return 'compressed_size';
            case BuildOrderBy.IsDraft: return 'is_draft';
            case BuildOrderBy.IsDeleted: return 'is_deleted';
            case BuildOrderBy.CreatedAt: return 'created_at';
            case BuildOrderBy.UpdatedAt: return 'updated_at';
            default: throw new Error(`Invalid BuildOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): BuildOrderBy {
        switch (json) {
            case 'id': return BuildOrderBy.Id;
            case 'game_id': return BuildOrderBy.GameId;
            case 'game_title': return BuildOrderBy.GameTitle;
            case 'build_rev': return BuildOrderBy.BuildRev;
            case 'total_size': return BuildOrderBy.TotalSize;
            case 'compressed_size': return BuildOrderBy.CompressedSize;
            case 'is_draft': return BuildOrderBy.IsDraft;
            case 'is_deleted': return BuildOrderBy.IsDeleted;
            case 'created_at': return BuildOrderBy.CreatedAt;
            case 'updated_at': return BuildOrderBy.UpdatedAt;
            default: throw new Error(`Invalid BuildOrderBy value: ${json}`);
        }
    }

    export function getDescription(value: BuildOrderBy): string {
        switch (value) {
            case BuildOrderBy.Id: return '';
            case BuildOrderBy.GameId: return '';
            case BuildOrderBy.GameTitle: return '';
            case BuildOrderBy.BuildRev: return '';
            case BuildOrderBy.TotalSize: return '';
            case BuildOrderBy.CompressedSize: return '';
            case BuildOrderBy.IsDraft: return '';
            case BuildOrderBy.IsDeleted: return '';
            case BuildOrderBy.CreatedAt: return '';
            case BuildOrderBy.UpdatedAt: return '';
            default: return '';
        }
    }
}

export class BuildFile {
    id!: number;
    buildId!: number;
    filePath!: string;
    fileSize!: number;
    compressedFilePath!: string;
    compressedFileSize!: number;
    md5!: string;
    createdAt!: Date;
    updatedAt!: Date;

    static fromJson(json: Igor.Json.JsonValue): BuildFile {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BuildFile();
        obj.id = jsonObject['id'] as number;
        obj.buildId = jsonObject['build_id'] as number;
        obj.filePath = jsonObject['file_path'] as string;
        obj.fileSize = jsonObject['file_size'] as number;
        obj.compressedFilePath = jsonObject['compressed_file_path'] as string;
        obj.compressedFileSize = jsonObject['compressed_file_size'] as number;
        obj.md5 = jsonObject['md5'] as string;
        obj.createdAt = Igor.Json.DateSerializer.fromJson(jsonObject['created_at']);
        obj.updatedAt = Igor.Json.DateSerializer.fromJson(jsonObject['updated_at']);
        return obj;
    }

    static toJson(value: BuildFile): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['build_id'] = value.buildId;
        result['file_path'] = value.filePath;
        result['file_size'] = value.fileSize;
        result['compressed_file_path'] = value.compressedFilePath;
        result['compressed_file_size'] = value.compressedFileSize;
        result['md5'] = value.md5;
        result['created_at'] = Igor.Json.DateSerializer.toJson(value.createdAt);
        result['updated_at'] = Igor.Json.DateSerializer.toJson(value.updatedAt);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return BuildFile.toJson(this);
    }
}

export class DraftBuildCreateRequest {
    buildRev!: string;
    platform!: Platform;

    static fromJson(json: Igor.Json.JsonValue): DraftBuildCreateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new DraftBuildCreateRequest();
        obj.buildRev = jsonObject['build_rev'] as string;
        obj.platform = Platform.fromJson(jsonObject['platform']);
        return obj;
    }

    static toJson(value: DraftBuildCreateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['build_rev'] = value.buildRev;
        result['platform'] = Platform.toJson(value.platform);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return DraftBuildCreateRequest.toJson(this);
    }
}

export enum DraftBuildCreateError {
    Failure = 1,
    InvalidGameId = 2,
    InvalidBuildRev = 3,
    InvalidPlatform = 4,
    BuildRevAlreadyExists = 5,
}

export namespace DraftBuildCreateError {
    export function toJson(value: DraftBuildCreateError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): DraftBuildCreateError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: DraftBuildCreateError): Igor.Json.JsonValue {
        switch (value) {
            case DraftBuildCreateError.Failure: return 'failure';
            case DraftBuildCreateError.InvalidGameId: return 'invalid_game_id';
            case DraftBuildCreateError.InvalidBuildRev: return 'invalid_build_rev';
            case DraftBuildCreateError.InvalidPlatform: return 'invalid_platform';
            case DraftBuildCreateError.BuildRevAlreadyExists: return 'build_rev_already_exists';
            default: throw new Error(`Invalid DraftBuildCreateError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): DraftBuildCreateError {
        switch (json) {
            case 'failure': return DraftBuildCreateError.Failure;
            case 'invalid_game_id': return DraftBuildCreateError.InvalidGameId;
            case 'invalid_build_rev': return DraftBuildCreateError.InvalidBuildRev;
            case 'invalid_platform': return DraftBuildCreateError.InvalidPlatform;
            case 'build_rev_already_exists': return DraftBuildCreateError.BuildRevAlreadyExists;
            default: throw new Error(`Invalid DraftBuildCreateError value: ${json}`);
        }
    }

    export function getDescription(value: DraftBuildCreateError): string {
        switch (value) {
            case DraftBuildCreateError.Failure: return '';
            case DraftBuildCreateError.InvalidGameId: return '';
            case DraftBuildCreateError.InvalidBuildRev: return '';
            case DraftBuildCreateError.InvalidPlatform: return '';
            case DraftBuildCreateError.BuildRevAlreadyExists: return '';
            default: return '';
        }
    }
}

export class DraftBuildCreateResponse implements IResult {
    result!: boolean;
    error?: DraftBuildCreateError | null = null;
    build?: Build | null = null;

    static fromJson(json: Igor.Json.JsonValue): DraftBuildCreateResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new DraftBuildCreateResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? DraftBuildCreateError.fromJson(jsonObject['error']) : null;
        obj.build = ('build' in jsonObject && jsonObject['build'] != null) ? Build.fromJson(jsonObject['build']) : null;
        return obj;
    }

    static toJson(value: DraftBuildCreateResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = DraftBuildCreateError.toJson(value.error);
        if (value.build != null) result['build'] = value.build.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return DraftBuildCreateResponse.toJson(this);
    }
}

export class DraftBuildUpdateRequest {
    commentary?: string | null = null;
    changeList?: string | null = null;
    exePath?: string | null = null;
    logPath?: string | null = null;
    crashReportPath?: string | null = null;
    configPath?: string | null = null;
    optionalFileMasks?: Array<string> | null = null;
    preservedFileMasks?: Array<string> | null = null;
    redistributables?: Array<RedistributableEntry> | null = null;
    pdbFiles?: Array<string> | null = null;
    platform?: Platform | null = null;

    static fromJson(json: Igor.Json.JsonValue): DraftBuildUpdateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new DraftBuildUpdateRequest();
        obj.commentary = ('commentary' in jsonObject && jsonObject['commentary'] != null) ? jsonObject['commentary'] as string : null;
        obj.changeList = ('change_list' in jsonObject && jsonObject['change_list'] != null) ? jsonObject['change_list'] as string : null;
        obj.exePath = ('exe_path' in jsonObject && jsonObject['exe_path'] != null) ? jsonObject['exe_path'] as string : null;
        obj.logPath = ('log_path' in jsonObject && jsonObject['log_path'] != null) ? jsonObject['log_path'] as string : null;
        obj.crashReportPath = ('crash_report_path' in jsonObject && jsonObject['crash_report_path'] != null) ? jsonObject['crash_report_path'] as string : null;
        obj.configPath = ('config_path' in jsonObject && jsonObject['config_path'] != null) ? jsonObject['config_path'] as string : null;
        obj.optionalFileMasks = ('optional_file_masks' in jsonObject && jsonObject['optional_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['optional_file_masks']) : null;
        obj.preservedFileMasks = ('preserved_file_masks' in jsonObject && jsonObject['preserved_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['preserved_file_masks']) : null;
        obj.redistributables = ('redistributables' in jsonObject && jsonObject['redistributables'] != null) ? Igor.Json.List(RedistributableEntry).fromJson(jsonObject['redistributables']) : null;
        obj.pdbFiles = ('pdb_files' in jsonObject && jsonObject['pdb_files'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['pdb_files']) : null;
        obj.platform = ('platform' in jsonObject && jsonObject['platform'] != null) ? Platform.fromJson(jsonObject['platform']) : null;
        return obj;
    }

    static toJson(value: DraftBuildUpdateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.commentary != null) result['commentary'] = value.commentary;
        if (value.changeList != null) result['change_list'] = value.changeList;
        if (value.exePath != null) result['exe_path'] = value.exePath;
        if (value.logPath != null) result['log_path'] = value.logPath;
        if (value.crashReportPath != null) result['crash_report_path'] = value.crashReportPath;
        if (value.configPath != null) result['config_path'] = value.configPath;
        if (value.optionalFileMasks != null) result['optional_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.optionalFileMasks);
        if (value.preservedFileMasks != null) result['preserved_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.preservedFileMasks);
        if (value.redistributables != null) result['redistributables'] = Igor.Json.List(RedistributableEntry).toJson(value.redistributables);
        if (value.pdbFiles != null) result['pdb_files'] = Igor.Json.List(Igor.Json.String).toJson(value.pdbFiles);
        if (value.platform != null) result['platform'] = Platform.toJson(value.platform);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return DraftBuildUpdateRequest.toJson(this);
    }
}

export enum DraftBuildUpdateError {
    Failure = 1,
    RevMismatch = 2,
    InvalidPlatform = 3,
}

export namespace DraftBuildUpdateError {
    export function toJson(value: DraftBuildUpdateError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): DraftBuildUpdateError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: DraftBuildUpdateError): Igor.Json.JsonValue {
        switch (value) {
            case DraftBuildUpdateError.Failure: return 'failure';
            case DraftBuildUpdateError.RevMismatch: return 'rev_mismatch';
            case DraftBuildUpdateError.InvalidPlatform: return 'invalid_platform';
            default: throw new Error(`Invalid DraftBuildUpdateError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): DraftBuildUpdateError {
        switch (json) {
            case 'failure': return DraftBuildUpdateError.Failure;
            case 'rev_mismatch': return DraftBuildUpdateError.RevMismatch;
            case 'invalid_platform': return DraftBuildUpdateError.InvalidPlatform;
            default: throw new Error(`Invalid DraftBuildUpdateError value: ${json}`);
        }
    }

    export function getDescription(value: DraftBuildUpdateError): string {
        switch (value) {
            case DraftBuildUpdateError.Failure: return '';
            case DraftBuildUpdateError.RevMismatch: return '';
            case DraftBuildUpdateError.InvalidPlatform: return '';
            default: return '';
        }
    }
}

export class DraftBuildUpdateResponse implements IResult {
    result!: boolean;
    error?: DraftBuildUpdateError | null = null;
    build?: Build | null = null;

    static fromJson(json: Igor.Json.JsonValue): DraftBuildUpdateResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new DraftBuildUpdateResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? DraftBuildUpdateError.fromJson(jsonObject['error']) : null;
        obj.build = ('build' in jsonObject && jsonObject['build'] != null) ? Build.fromJson(jsonObject['build']) : null;
        return obj;
    }

    static toJson(value: DraftBuildUpdateResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = DraftBuildUpdateError.toJson(value.error);
        if (value.build != null) result['build'] = value.build.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return DraftBuildUpdateResponse.toJson(this);
    }
}

export enum BuildPublishError {
    Failure = 1,
    AlreadyPublished = 2,
    NoFiles = 3,
    MissingFiles = 4,
    InvalidExePath = 5,
}

export namespace BuildPublishError {
    export function toJson(value: BuildPublishError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): BuildPublishError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: BuildPublishError): Igor.Json.JsonValue {
        switch (value) {
            case BuildPublishError.Failure: return 'failure';
            case BuildPublishError.AlreadyPublished: return 'already_published';
            case BuildPublishError.NoFiles: return 'no_files';
            case BuildPublishError.MissingFiles: return 'missing_files';
            case BuildPublishError.InvalidExePath: return 'invalid_exe_path';
            default: throw new Error(`Invalid BuildPublishError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): BuildPublishError {
        switch (json) {
            case 'failure': return BuildPublishError.Failure;
            case 'already_published': return BuildPublishError.AlreadyPublished;
            case 'no_files': return BuildPublishError.NoFiles;
            case 'missing_files': return BuildPublishError.MissingFiles;
            case 'invalid_exe_path': return BuildPublishError.InvalidExePath;
            default: throw new Error(`Invalid BuildPublishError value: ${json}`);
        }
    }

    export function getDescription(value: BuildPublishError): string {
        switch (value) {
            case BuildPublishError.Failure: return '';
            case BuildPublishError.AlreadyPublished: return '';
            case BuildPublishError.NoFiles: return '';
            case BuildPublishError.MissingFiles: return '';
            case BuildPublishError.InvalidExePath: return '';
            default: return '';
        }
    }
}

export class BuildPublishResponse implements IResult {
    result!: boolean;
    error?: BuildPublishError | null = null;
    build?: Build | null = null;

    static fromJson(json: Igor.Json.JsonValue): BuildPublishResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BuildPublishResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? BuildPublishError.fromJson(jsonObject['error']) : null;
        obj.build = ('build' in jsonObject && jsonObject['build'] != null) ? Build.fromJson(jsonObject['build']) : null;
        return obj;
    }

    static toJson(value: BuildPublishResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = BuildPublishError.toJson(value.error);
        if (value.build != null) result['build'] = value.build.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return BuildPublishResponse.toJson(this);
    }
}

export class BuildUpdateRequest {
    commentary?: string | null = null;
    changeList?: string | null = null;
    configPath?: string | null = null;
    optionalFileMasks?: Array<string> | null = null;
    preservedFileMasks?: Array<string> | null = null;
    redistributables?: Array<RedistributableEntry> | null = null;
    pdbFiles?: Array<string> | null = null;
    isPermanent?: boolean | null = null;

    static fromJson(json: Igor.Json.JsonValue): BuildUpdateRequest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BuildUpdateRequest();
        obj.commentary = ('commentary' in jsonObject && jsonObject['commentary'] != null) ? jsonObject['commentary'] as string : null;
        obj.changeList = ('change_list' in jsonObject && jsonObject['change_list'] != null) ? jsonObject['change_list'] as string : null;
        obj.configPath = ('config_path' in jsonObject && jsonObject['config_path'] != null) ? jsonObject['config_path'] as string : null;
        obj.optionalFileMasks = ('optional_file_masks' in jsonObject && jsonObject['optional_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['optional_file_masks']) : null;
        obj.preservedFileMasks = ('preserved_file_masks' in jsonObject && jsonObject['preserved_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['preserved_file_masks']) : null;
        obj.redistributables = ('redistributables' in jsonObject && jsonObject['redistributables'] != null) ? Igor.Json.List(RedistributableEntry).fromJson(jsonObject['redistributables']) : null;
        obj.pdbFiles = ('pdb_files' in jsonObject && jsonObject['pdb_files'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['pdb_files']) : null;
        obj.isPermanent = ('is_permanent' in jsonObject && jsonObject['is_permanent'] != null) ? jsonObject['is_permanent'] as boolean : null;
        return obj;
    }

    static toJson(value: BuildUpdateRequest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        if (value.commentary != null) result['commentary'] = value.commentary;
        if (value.changeList != null) result['change_list'] = value.changeList;
        if (value.configPath != null) result['config_path'] = value.configPath;
        if (value.optionalFileMasks != null) result['optional_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.optionalFileMasks);
        if (value.preservedFileMasks != null) result['preserved_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.preservedFileMasks);
        if (value.redistributables != null) result['redistributables'] = Igor.Json.List(RedistributableEntry).toJson(value.redistributables);
        if (value.pdbFiles != null) result['pdb_files'] = Igor.Json.List(Igor.Json.String).toJson(value.pdbFiles);
        if (value.isPermanent != null) result['is_permanent'] = value.isPermanent;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return BuildUpdateRequest.toJson(this);
    }
}

export enum BuildUpdateError {
    Failure = 1,
    RevMismatch = 2,
    NothingToUpdate = 3,
}

export namespace BuildUpdateError {
    export function toJson(value: BuildUpdateError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): BuildUpdateError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: BuildUpdateError): Igor.Json.JsonValue {
        switch (value) {
            case BuildUpdateError.Failure: return 'failure';
            case BuildUpdateError.RevMismatch: return 'rev_mismatch';
            case BuildUpdateError.NothingToUpdate: return 'nothing_to_update';
            default: throw new Error(`Invalid BuildUpdateError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): BuildUpdateError {
        switch (json) {
            case 'failure': return BuildUpdateError.Failure;
            case 'rev_mismatch': return BuildUpdateError.RevMismatch;
            case 'nothing_to_update': return BuildUpdateError.NothingToUpdate;
            default: throw new Error(`Invalid BuildUpdateError value: ${json}`);
        }
    }

    export function getDescription(value: BuildUpdateError): string {
        switch (value) {
            case BuildUpdateError.Failure: return '';
            case BuildUpdateError.RevMismatch: return '';
            case BuildUpdateError.NothingToUpdate: return '';
            default: return '';
        }
    }
}

export class BuildUpdateResponse implements IResult {
    result!: boolean;
    error?: BuildUpdateError | null = null;
    build?: Build | null = null;

    static fromJson(json: Igor.Json.JsonValue): BuildUpdateResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BuildUpdateResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? BuildUpdateError.fromJson(jsonObject['error']) : null;
        obj.build = ('build' in jsonObject && jsonObject['build'] != null) ? Build.fromJson(jsonObject['build']) : null;
        return obj;
    }

    static toJson(value: BuildUpdateResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = BuildUpdateError.toJson(value.error);
        if (value.build != null) result['build'] = value.build.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return BuildUpdateResponse.toJson(this);
    }
}

export enum BuildDeleteError {
    Failure = 1,
    AlreadyDeleted = 2,
    HasAssignedBranches = 3,
}

export namespace BuildDeleteError {
    export function toJson(value: BuildDeleteError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): BuildDeleteError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: BuildDeleteError): Igor.Json.JsonValue {
        switch (value) {
            case BuildDeleteError.Failure: return 'failure';
            case BuildDeleteError.AlreadyDeleted: return 'already_deleted';
            case BuildDeleteError.HasAssignedBranches: return 'has_assigned_branches';
            default: throw new Error(`Invalid BuildDeleteError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): BuildDeleteError {
        switch (json) {
            case 'failure': return BuildDeleteError.Failure;
            case 'already_deleted': return BuildDeleteError.AlreadyDeleted;
            case 'has_assigned_branches': return BuildDeleteError.HasAssignedBranches;
            default: throw new Error(`Invalid BuildDeleteError value: ${json}`);
        }
    }

    export function getDescription(value: BuildDeleteError): string {
        switch (value) {
            case BuildDeleteError.Failure: return '';
            case BuildDeleteError.AlreadyDeleted: return '';
            case BuildDeleteError.HasAssignedBranches: return '';
            default: return '';
        }
    }
}

export class BuildDeleteResponse implements IResult {
    result!: boolean;
    error?: BuildDeleteError | null = null;
    build?: Build | null = null;

    static fromJson(json: Igor.Json.JsonValue): BuildDeleteResponse {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BuildDeleteResponse();
        obj.result = jsonObject['result'] as boolean;
        obj.error = ('error' in jsonObject && jsonObject['error'] != null) ? BuildDeleteError.fromJson(jsonObject['error']) : null;
        obj.build = ('build' in jsonObject && jsonObject['build'] != null) ? Build.fromJson(jsonObject['build']) : null;
        return obj;
    }

    static toJson(value: BuildDeleteResponse): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['result'] = value.result;
        if (value.error != null) result['error'] = BuildDeleteError.toJson(value.error);
        if (value.build != null) result['build'] = value.build.toJson();
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return BuildDeleteResponse.toJson(this);
    }
}

export class PopularGame {
    id!: string;
    title!: string;
    description!: string;
    price!: number;
    currency!: string;
    purchases!: number;

    static fromJson(json: Igor.Json.JsonValue): PopularGame {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new PopularGame();
        obj.id = jsonObject['id'] as string;
        obj.title = jsonObject['title'] as string;
        obj.description = jsonObject['description'] as string;
        obj.price = jsonObject['price'] as number;
        obj.currency = jsonObject['currency'] as string;
        obj.purchases = jsonObject['purchases'] as number;
        return obj;
    }

    static toJson(value: PopularGame): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['id'] = value.id;
        result['title'] = value.title;
        result['description'] = value.description;
        result['price'] = value.price;
        result['currency'] = value.currency;
        result['purchases'] = value.purchases;
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return PopularGame.toJson(this);
    }
}

export enum PopularGameOrderBy {
    Purchases = 1,
}

export namespace PopularGameOrderBy {
    export function toJson(value: PopularGameOrderBy): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): PopularGameOrderBy {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: PopularGameOrderBy): Igor.Json.JsonValue {
        switch (value) {
            case PopularGameOrderBy.Purchases: return 'purchases';
            default: throw new Error(`Invalid PopularGameOrderBy value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): PopularGameOrderBy {
        switch (json) {
            case 'purchases': return PopularGameOrderBy.Purchases;
            default: throw new Error(`Invalid PopularGameOrderBy value: ${json}`);
        }
    }

    export function getDescription(value: PopularGameOrderBy): string {
        switch (value) {
            case PopularGameOrderBy.Purchases: return '';
            default: return '';
        }
    }
}

export class BuildManifest {
    guid!: string;
    branch!: string;
    buildRev!: string;
    cdnRootUrl!: string;
    totalBuildSize!: number;
    totalCompressedSize!: number;
    exePath!: string;
    logPath!: string;
    crashReportPath!: string;
    configPath!: string;
    optionalFileMasks: Array<string> = [];
    preservedFileMasks: Array<string> = [];
    redistributables: Array<RedistributableEntry> = [];
    pdbFiles: Array<string> = [];
    platform: Platform = Platform.Windows;
    files!: Array<GameFile>;

    static fromJson(json: Igor.Json.JsonValue): BuildManifest {
        const jsonObject = json as Igor.Json.JsonObject;
        const obj = new BuildManifest();
        obj.guid = jsonObject['guid'] as string;
        obj.branch = jsonObject['branch'] as string;
        obj.buildRev = jsonObject['build_rev'] as string;
        obj.cdnRootUrl = jsonObject['cdn_root_url'] as string;
        obj.totalBuildSize = jsonObject['total_build_size'] as number;
        obj.totalCompressedSize = jsonObject['total_compressed_size'] as number;
        obj.exePath = jsonObject['exe_path'] as string;
        obj.logPath = jsonObject['log_path'] as string;
        obj.crashReportPath = jsonObject['crash_report_path'] as string;
        obj.configPath = jsonObject['config_path'] as string;
        obj.optionalFileMasks = ('optional_file_masks' in jsonObject && jsonObject['optional_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['optional_file_masks']) : [];
        obj.preservedFileMasks = ('preserved_file_masks' in jsonObject && jsonObject['preserved_file_masks'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['preserved_file_masks']) : [];
        obj.redistributables = ('redistributables' in jsonObject && jsonObject['redistributables'] != null) ? Igor.Json.List(RedistributableEntry).fromJson(jsonObject['redistributables']) : [];
        obj.pdbFiles = ('pdb_files' in jsonObject && jsonObject['pdb_files'] != null) ? Igor.Json.List(Igor.Json.String).fromJson(jsonObject['pdb_files']) : [];
        obj.platform = ('platform' in jsonObject && jsonObject['platform'] != null) ? Platform.fromJson(jsonObject['platform']) : Platform.Windows;
        obj.files = Igor.Json.List(GameFile).fromJson(jsonObject['files']);
        return obj;
    }

    static toJson(value: BuildManifest): Igor.Json.JsonValue {
        const result: Igor.Json.JsonObject = {};
        result['guid'] = value.guid;
        result['branch'] = value.branch;
        result['build_rev'] = value.buildRev;
        result['cdn_root_url'] = value.cdnRootUrl;
        result['total_build_size'] = value.totalBuildSize;
        result['total_compressed_size'] = value.totalCompressedSize;
        result['exe_path'] = value.exePath;
        result['log_path'] = value.logPath;
        result['crash_report_path'] = value.crashReportPath;
        result['config_path'] = value.configPath;
        result['optional_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.optionalFileMasks);
        result['preserved_file_masks'] = Igor.Json.List(Igor.Json.String).toJson(value.preservedFileMasks);
        result['redistributables'] = Igor.Json.List(RedistributableEntry).toJson(value.redistributables);
        result['pdb_files'] = Igor.Json.List(Igor.Json.String).toJson(value.pdbFiles);
        result['platform'] = Platform.toJson(value.platform);
        result['files'] = Igor.Json.List(GameFile).toJson(value.files);
        return result;
    }

    toJson(): Igor.Json.JsonValue {
        return BuildManifest.toJson(this);
    }
}

export enum AddGameBuildError {
    Failure = 1,
    InvalidApiKey = 2,
    InvalidGame = 3,
    InvalidBranch = 4,
    InvalidExePath = 5,
    BuildAlreadyExists = 6,
    PlatformMismatch = 7,
}

export namespace AddGameBuildError {
    export function toJson(value: AddGameBuildError): Igor.Json.JsonValue {
        return toJsonKey(value);
    }

    export function fromJson(json: Igor.Json.JsonValue): AddGameBuildError {
        return fromJsonKey(json);
    }

    export function toJsonKey(value: AddGameBuildError): Igor.Json.JsonValue {
        switch (value) {
            case AddGameBuildError.Failure: return 'failure';
            case AddGameBuildError.InvalidApiKey: return 'invalid_api_key';
            case AddGameBuildError.InvalidGame: return 'invalid_game';
            case AddGameBuildError.InvalidBranch: return 'invalid_branch';
            case AddGameBuildError.InvalidExePath: return 'invalid_exe_path';
            case AddGameBuildError.BuildAlreadyExists: return 'build_already_exists';
            case AddGameBuildError.PlatformMismatch: return 'platform_mismatch';
            default: throw new Error(`Invalid AddGameBuildError value: ${value}`);
        }
    }

    export function fromJsonKey(json: Igor.Json.JsonValue): AddGameBuildError {
        switch (json) {
            case 'failure': return AddGameBuildError.Failure;
            case 'invalid_api_key': return AddGameBuildError.InvalidApiKey;
            case 'invalid_game': return AddGameBuildError.InvalidGame;
            case 'invalid_branch': return AddGameBuildError.InvalidBranch;
            case 'invalid_exe_path': return AddGameBuildError.InvalidExePath;
            case 'build_already_exists': return AddGameBuildError.BuildAlreadyExists;
            case 'platform_mismatch': return AddGameBuildError.PlatformMismatch;
            default: throw new Error(`Invalid AddGameBuildError value: ${json}`);
        }
    }

    export function getDescription(value: AddGameBuildError): string {
        switch (value) {
            case AddGameBuildError.Failure: return '';
            case AddGameBuildError.InvalidApiKey: return '';
            case AddGameBuildError.InvalidGame: return '';
            case AddGameBuildError.InvalidBranch: return '';
            case AddGameBuildError.InvalidExePath: return '';
            case AddGameBuildError.BuildAlreadyExists: return '';
            case AddGameBuildError.PlatformMismatch: return '';
            default: return '';
        }
    }
}
