// Author: Igor compiler
// Compiler version: igorc 2.1.3
// DO NOT EDIT THIS FILE - it is machine generated

import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import * as Igor from './igor';
import * as WebProtocol from './web-protocol.data';

@Injectable({
    providedIn: 'root',
})
export class HeliosAdminService {
    public baseUrl = '';

    constructor(private http: HttpClient) { }

    public getGameCategories(): Observable<WebProtocol.Collection<WebProtocol.GameCategory>> {
        return this.http
            .get(`${this.baseUrl}/api/admin/categories`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.Collection.instanceJsonSerializer<WebProtocol.GameCategory>(WebProtocol.GameCategory).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getGameCategory(id: number): Observable<WebProtocol.GameCategory> {
        return this.http
            .get(`${this.baseUrl}/api/admin/category/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameCategory.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createGameCategory(request: WebProtocol.GameCategoryCreateRequest): Observable<WebProtocol.GameCategoryManageResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/admin/categories`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameCategoryManageResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateGameCategory(request: WebProtocol.GameCategoryUpdateRequest, id: number, rev: number): Observable<WebProtocol.GameCategoryManageResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/category/${id}/${rev}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameCategoryManageResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public deleteGameCategory(id: number): Observable<WebProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/category/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getGame(guid: string): Observable<WebProtocol.Game> {
        return this.http
            .get(`${this.baseUrl}/api/admin/game/${guid}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.Game.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getMyRolesForGame(guid: string): Observable<WebProtocol.PersonnelAccountRole> {
        return this.http
            .get(`${this.baseUrl}/api/admin/game/${guid}/roles/me`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.PersonnelAccountRole.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelAccountRolesForGame(guid: string, needle: string | null = null, orderBy: WebProtocol.PersonnelAccountRoleOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.PersonnelAccountRole>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${WebProtocol.PersonnelAccountRoleOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/game/${guid}/roles/account${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.PersonnelAccountRole>(WebProtocol.PersonnelAccountRole).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroupRolesForGame(guid: string, needle: string | null = null, orderBy: WebProtocol.PersonnelGroupRoleOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.PersonnelGroupRole>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${WebProtocol.PersonnelGroupRoleOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/game/${guid}/roles/group${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.PersonnelGroupRole>(WebProtocol.PersonnelGroupRole).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getGames(needle: string | null = null, orderBy: WebProtocol.GameOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.Game>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${WebProtocol.GameOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/games${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.Game>(WebProtocol.Game).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getFavouriteGames(): Observable<WebProtocol.Collection<WebProtocol.Game>> {
        return this.http
            .get(`${this.baseUrl}/api/admin/games/favourite`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                            case 500: return throwError(WebProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.Collection.instanceJsonSerializer<WebProtocol.Game>(WebProtocol.Game).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createGame(request: WebProtocol.GameCreateRequest): Observable<WebProtocol.GameCreateResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/admin/games`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameCreateResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateGame(request: WebProtocol.GameUpdateRequest, guid: string, rev: number): Observable<WebProtocol.GameUpdateResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/game/${guid}/${rev}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameUpdateResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public isFavouriteGame(guid: string): Observable<WebProtocol.GenericResponse> {
        return this.http
            .get(`${this.baseUrl}/api/admin/game/${guid}/favourite`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                            case 500: return throwError(WebProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public favourGame(request: WebProtocol.Empty, guid: string): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/game/${guid}/favourite`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(WebProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(WebProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public unfavourGame(guid: string): Observable<WebProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/game/${guid}/favourite`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(WebProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(WebProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public assignGameCategory(request: WebProtocol.Empty, guid: string, categoryId: number): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/game/${guid}/category/${categoryId}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(WebProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(WebProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public unassignGameCategory(guid: string, categoryId: number): Observable<WebProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/game/${guid}/category/${categoryId}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                            case 404: return throwError(WebProtocol.NotFoundError.fromJson(response.error));
                            case 500: return throwError(WebProtocol.InternalServerError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPopularGames(orderBy: WebProtocol.PopularGameOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.PopularGame>> {
        return this.http
            .get(`${this.baseUrl}/api/admin/statistics/games/popular?order_by=${WebProtocol.PopularGameOrderBy.toJson(orderBy)}&order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}&offset=${offset}&limit=${limit}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.PopularGame>(WebProtocol.PopularGame).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getGameBranch(id: number): Observable<WebProtocol.GameBranch> {
        return this.http
            .get(`${this.baseUrl}/api/admin/branch/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameBranch.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getGameBranches(guid: string, orderBy: WebProtocol.GameBranchOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.GameBranch>> {
        return this.http
            .get(`${this.baseUrl}/api/admin/branches/${guid}?order_by=${WebProtocol.GameBranchOrderBy.toJson(orderBy)}&order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}&offset=${offset}&limit=${limit}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.GameBranch>(WebProtocol.GameBranch).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getAllGameBranches(guid: string): Observable<Array<WebProtocol.GameBranch>> {
        return this.http
            .get(`${this.baseUrl}/api/admin/branches/${guid}/all`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => Igor.Json.List(WebProtocol.GameBranch).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createGameBranch(request: WebProtocol.GameBranchCreateRequest, guid: string): Observable<WebProtocol.GameBranchCreateResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/admin/branches/${guid}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameBranchCreateResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateGameBranch(request: WebProtocol.GameBranchUpdateRequest, id: number, rev: number): Observable<WebProtocol.GameBranchUpdateResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/branch/${id}/${rev}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameBranchUpdateResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public setGameBranchBuild(request: WebProtocol.GameBranchBuildRequest, id: number): Observable<WebProtocol.GameBranchBuildResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/branch/${id}/build`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameBranchBuildResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public setGameBranchAsDefault(request: WebProtocol.Empty, id: number): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/branch/${id}/default`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getBuild(id: number): Observable<WebProtocol.Build> {
        return this.http
            .get(`${this.baseUrl}/api/admin/build/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.Build.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getBuildByRev(guid: string, buildRev: string): Observable<WebProtocol.Build> {
        return this.http
            .get(`${this.baseUrl}/api/admin/build/${guid}/rev/${buildRev}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.Build.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getBuilds(orderBy: WebProtocol.BuildOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number, activeOnly: boolean | null = null): Observable<WebProtocol.CollectionSlice<WebProtocol.Build>> {
        const queryParams: Array<string> = [];
        queryParams.push(`order_by=${WebProtocol.BuildOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        if (activeOnly != null)
            queryParams.push(`active_only=${activeOnly}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/builds${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.Build>(WebProtocol.Build).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getBuildsForGame(guid: string, orderBy: WebProtocol.BuildOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.Build>> {
        return this.http
            .get(`${this.baseUrl}/api/admin/builds/game/${guid}?order_by=${WebProtocol.BuildOrderBy.toJson(orderBy)}&order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}&offset=${offset}&limit=${limit}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.Build>(WebProtocol.Build).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public createDraftBuild(request: WebProtocol.DraftBuildCreateRequest, guid: string): Observable<WebProtocol.DraftBuildCreateResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/admin/builds/game/${guid}/draft`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.DraftBuildCreateResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateDraftBuild(request: WebProtocol.DraftBuildUpdateRequest, id: number, rev: number): Observable<WebProtocol.DraftBuildUpdateResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/build/${id}/${rev}/draft`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.DraftBuildUpdateResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public publishDraftBuild(request: WebProtocol.Empty, id: number): Observable<WebProtocol.BuildPublishResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/build/${id}/draft/publish`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.BuildPublishResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateBuild(request: WebProtocol.BuildUpdateRequest, id: number, rev: number): Observable<WebProtocol.BuildUpdateResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/build/${id}/${rev}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.BuildUpdateResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public deleteBuild(id: number): Observable<WebProtocol.BuildDeleteResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/build/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.BuildDeleteResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getBuildManifest(id: number): Observable<WebProtocol.GameManifest> {
        return this.http
            .get(`${this.baseUrl}/api/admin/build/${id}/manifest`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GameManifest.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getBuildFiles(id: number): Observable<WebProtocol.Collection<WebProtocol.BuildFile>> {
        return this.http
            .get(`${this.baseUrl}/api/admin/build/${id}/files`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.Collection.instanceJsonSerializer<WebProtocol.BuildFile>(WebProtocol.BuildFile).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public deleteAllBuildFiles(id: number): Observable<WebProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/build/${id}/files`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public deleteBuildFile(id: number, fileId: number): Observable<WebProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/build/${id}/files/${fileId}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getClientAccount(id: number): Observable<WebProtocol.ClientAccount> {
        return this.http
            .get(`${this.baseUrl}/api/admin/client/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.ClientAccount.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getClientAccounts(needle: string | null = null, orderBy: WebProtocol.ClientAccountOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.ClientAccount>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${WebProtocol.ClientAccountOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/clients${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.ClientAccount>(WebProtocol.ClientAccount).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelAccount(id: number): Observable<WebProtocol.PersonnelAccount> {
        return this.http
            .get(`${this.baseUrl}/api/admin/personnel/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.PersonnelAccount.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelAccountByUsername(username: string): Observable<WebProtocol.PersonnelAccount> {
        return this.http
            .get(`${this.baseUrl}/api/admin/personnel/username/${username}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.PersonnelAccount.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelAccounts(needle: string | null = null, orderBy: WebProtocol.PersonnelAccountOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.PersonnelAccount>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${WebProtocol.PersonnelAccountOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/personnels${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.PersonnelAccount>(WebProtocol.PersonnelAccount).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getMyPersonnelAccountRoles(needle: string | null = null, orderBy: WebProtocol.PersonnelAccountRoleOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.PersonnelAccountRole>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${WebProtocol.PersonnelAccountRoleOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/personnel/my/roles${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.PersonnelAccountRole>(WebProtocol.PersonnelAccountRole).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelAccountRoles(id: number, needle: string | null = null, orderBy: WebProtocol.PersonnelAccountRoleOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.PersonnelAccountRole>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${WebProtocol.PersonnelAccountRoleOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/personnel/${id}/roles${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.PersonnelAccountRole>(WebProtocol.PersonnelAccountRole).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public setPersonnelAccountRole(request: WebProtocol.AccessRoleUpdateRequest, id: number, guid: string): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/personnel/${id}/roles/${guid}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public resetPersonnelAccountRole(id: number, guid: string): Observable<WebProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/personnel/${id}/roles/${guid}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroup(id: number): Observable<WebProtocol.PersonnelGroup> {
        return this.http
            .get(`${this.baseUrl}/api/admin/personnel-groups/${id}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.PersonnelGroup.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroupByName(name: string): Observable<WebProtocol.PersonnelGroup> {
        return this.http
            .get(`${this.baseUrl}/api/admin/personnel-groups/name/${name}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.PersonnelGroup.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroups(needle: string | null = null, orderBy: WebProtocol.PersonnelGroupOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.PersonnelGroup>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${WebProtocol.PersonnelGroupOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/personnel-groups${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.PersonnelGroup>(WebProtocol.PersonnelGroup).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelGroupRoles(id: number, needle: string | null = null, orderBy: WebProtocol.PersonnelGroupRoleOrderBy, orderDir: WebProtocol.OrderDirection, offset: number, limit: number): Observable<WebProtocol.CollectionSlice<WebProtocol.PersonnelGroupRole>> {
        const queryParams: Array<string> = [];
        if (needle != null)
            queryParams.push(`needle=${needle}`);
        queryParams.push(`order_by=${WebProtocol.PersonnelGroupRoleOrderBy.toJson(orderBy)}`);
        queryParams.push(`order_dir=${WebProtocol.OrderDirection.toJson(orderDir)}`);
        queryParams.push(`offset=${offset}`);
        queryParams.push(`limit=${limit}`);
        const queryString = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';

        return this.http
            .get(`${this.baseUrl}/api/admin/personnel-groups/${id}/roles${queryString}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.CollectionSlice.instanceJsonSerializer<WebProtocol.PersonnelGroupRole>(WebProtocol.PersonnelGroupRole).fromJson(response as Igor.Json.JsonValue))
            );
    }

    public setPersonnelGroupRole(request: WebProtocol.AccessRoleUpdateRequest, id: number, guid: string): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/personnel-groups/${id}/roles/${guid}`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public resetPersonnelGroupRole(id: number, guid: string): Observable<WebProtocol.GenericResponse> {
        return this.http
            .delete(`${this.baseUrl}/api/admin/personnel-groups/${id}/roles/${guid}`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getSettings(): Observable<WebProtocol.Settings> {
        return this.http
            .get(`${this.baseUrl}/api/admin/settings`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.Settings.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public updateSettings(request: WebProtocol.SettingsUpdateRequest): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/settings`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public regenerateCiApiKey(request: WebProtocol.Empty): Observable<WebProtocol.RegenerateCiApiKeyResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/admin/settings/ci_api_key`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.RegenerateCiApiKeyResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }
}
