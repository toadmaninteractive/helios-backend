// Author: Igor compiler
// Compiler version: igorc 2.1.3
// DO NOT EDIT THIS FILE - it is machine generated

import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpHeaders } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import * as Igor from './igor';
import * as WebProtocol from './web-protocol.data';

@Injectable({
    providedIn: 'root',
})
export class HeliosAuthService {
    public baseUrl = '';

    constructor(private http: HttpClient) { }

    public getClientStatus(): Observable<WebProtocol.ClientStatusResponse> {
        return this.http
            .get(`${this.baseUrl}/api/auth/client/status`)
            .pipe(
                map(response => WebProtocol.ClientStatusResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public registerClient(request: WebProtocol.ClientRegisterRequest): Observable<WebProtocol.ClientRegisterResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/auth/client/register`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.ClientRegisterResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public confirmClientRegistration(request: WebProtocol.ClientRegisterConfirmRequest): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/auth/client/confirm`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public resendRegistrationCode(request: WebProtocol.ClientResendRequest): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/auth/client/resend`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public loginClient(request: WebProtocol.ClientLoginRequest): Observable<WebProtocol.ClientLoginResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/auth/client/login`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.ClientLoginResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public logoutClient(request: WebProtocol.Empty): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/auth/client/logout`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public resetClientPassword(request: WebProtocol.ClientPasswordResetRequest): Observable<WebProtocol.ClientPasswordResetResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/auth/client/password/reset`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.ClientPasswordResetResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public confirmClientPasswordReset(request: WebProtocol.ClientPasswordResetConfirmRequest): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/auth/client/password/confirm`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public changeClientPassword(request: WebProtocol.ClientPasswordChangeRequest): Observable<WebProtocol.ClientPasswordChangeResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/auth/client/password/change`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.ClientPasswordChangeResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getPersonnelStatus(): Observable<WebProtocol.PersonnelStatusResponse> {
        return this.http
            .get(`${this.baseUrl}/api/auth/personnel/status`)
            .pipe(
                map(response => WebProtocol.PersonnelStatusResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public loginPersonnel(request: WebProtocol.PersonnelLoginRequest): Observable<WebProtocol.PersonnelLoginResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .post(`${this.baseUrl}/api/auth/personnel/login`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.PersonnelLoginResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public logoutPersonnel(request: WebProtocol.Empty): Observable<WebProtocol.GenericResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/auth/personnel/logout`, request.toJson(), options)
            .pipe(
                map(response => WebProtocol.GenericResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public getMyPersonnelProfile(): Observable<WebProtocol.PersonnelAccountProfile> {
        return this.http
            .get(`${this.baseUrl}/api/auth/personnel/profile`)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.PersonnelAccountProfile.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public regeneratePersonnelApiKey(request: WebProtocol.Empty): Observable<WebProtocol.PersonnelApiKeyUpdateResponse> {
        const options = { headers: new HttpHeaders({'Content-Type': 'application/json' }) };

        return this.http
            .put(`${this.baseUrl}/api/auth/personnel/api_key`, request.toJson(), options)
            .pipe(
                catchError(response => {
                    if (response instanceof HttpErrorResponse) {
                        switch (response.status) {
                            case 403: return throwError(WebProtocol.ForbiddenError.fromJson(response.error));
                        }
                    }
                    return throwError(response);
                }),
                map(response => WebProtocol.PersonnelApiKeyUpdateResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }

    public requestCaptcha(): Observable<WebProtocol.CaptchaResponse> {
        return this.http
            .get(`${this.baseUrl}/api/captcha`)
            .pipe(
                map(response => WebProtocol.CaptchaResponse.fromJson(response as Igor.Json.JsonValue))
            );
    }
}
